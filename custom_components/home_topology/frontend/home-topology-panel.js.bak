var Aa = Object.create;
var fi = Object.defineProperty;
var Sa = Object.getOwnPropertyDescriptor;
var _s = (s, t) => (t = Symbol[s]) ? t : Symbol.for("Symbol." + s), qt = (s) => {
  throw TypeError(s);
};
var Ea = (s, t, e) => t in s ? fi(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var vs = (s, t) => fi(s, "name", { value: t, configurable: !0 });
var xe = (s) => [, , , Aa((s == null ? void 0 : s[_s("metadata")]) ?? null)], ys = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Gt = (s) => s !== void 0 && typeof s != "function" ? qt("Function expected") : s, Ca = (s, t, e, i, r) => ({ kind: ys[s], name: t, metadata: i, addInitializer: (n) => e._ ? qt("Already initialized") : r.push(Gt(n || null)) }), wa = (s, t) => Ea(t, _s("metadata"), s[3]), Te = (s, t, e, i) => {
  for (var r = 0, n = s[t >> 1], o = n && n.length; r < o; r++) t & 1 ? n[r].call(e) : i = n[r].call(e, i);
  return i;
}, Re = (s, t, e, i, r, n) => {
  var o, c, a, l, h, d = t & 7, p = !!(t & 8), u = !!(t & 16), v = d > 3 ? s.length + 1 : d ? p ? 1 : 2 : 0, m = ys[d + 5], ms = d > 3 && (s[v - 1] = []), ba = s[v] || (s[v] = []), P = d && (!u && !p && (r = r.prototype), d < 5 && (d > 3 || !u) && Sa(d < 4 ? r : { get [e]() {
    return gs(this, n);
  }, set [e](T) {
    return $s(this, n, T);
  } }, e));
  d ? u && d < 4 && vs(n, (d > 2 ? "set " : d > 1 ? "get " : "") + e) : vs(r, e);
  for (var pi = i.length - 1; pi >= 0; pi--)
    l = Ca(d, e, a = {}, s[3], ba), d && (l.static = p, l.private = u, h = l.access = { has: u ? (T) => xa(r, T) : (T) => e in T }, d ^ 3 && (h.get = u ? (T) => (d ^ 1 ? gs : Ta)(T, r, d ^ 4 ? n : P.get) : (T) => T[e]), d > 2 && (h.set = u ? (T, ui) => $s(T, r, ui, d ^ 4 ? n : P.set) : (T, ui) => T[e] = ui)), c = (0, i[pi])(d ? d < 4 ? u ? n : P[m] : d > 4 ? void 0 : { get: P.get, set: P.set } : r, l), a._ = 1, d ^ 4 || c === void 0 ? Gt(c) && (d > 4 ? ms.unshift(c) : d ? u ? n = c : P[m] = c : r = c) : typeof c != "object" || c === null ? qt("Object expected") : (Gt(o = c.get) && (P.get = o), Gt(o = c.set) && (P.set = o), Gt(o = c.init) && ms.unshift(o));
  return d || wa(s, r), P && fi(r, e, P), u ? d ^ 4 ? n : P : r;
};
var mi = (s, t, e) => t.has(s) || qt("Cannot " + e), xa = (s, t) => Object(t) !== t ? qt('Cannot use the "in" operator on this value') : s.has(t), gs = (s, t, e) => (mi(s, t, "read from private field"), e ? e.call(s) : t.get(s));
var $s = (s, t, e, i) => (mi(s, t, "write to private field"), i ? i.call(s, e) : t.set(s, e), e), Ta = (s, t, e) => (mi(s, t, "access private method"), e);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const He = globalThis, Br = He.ShadowRoot && (He.ShadyCSS === void 0 || He.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, jr = Symbol(), bs = /* @__PURE__ */ new WeakMap();
let co = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== jr) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Br && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = bs.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && bs.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Ra = (s) => new co(typeof s == "string" ? s : s + "", void 0, jr), si = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new co(e, s, jr);
}, Pa = (s, t) => {
  if (Br) s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of t) {
    const i = document.createElement("style"), r = He.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  }
}, As = Br ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return Ra(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Oa, defineProperty: ka, getOwnPropertyDescriptor: Ha, getOwnPropertyNames: Ua, getOwnPropertySymbols: La, getPrototypeOf: Ia } = Object, F = globalThis, Ss = F.trustedTypes, Ma = Ss ? Ss.emptyScript : "", vi = F.reactiveElementPolyfillSupport, re = (s, t) => s, dr = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? Ma : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, ho = (s, t) => !Oa(s, t), Es = { attribute: !0, type: String, converter: dr, reflect: !1, useDefault: !1, hasChanged: ho };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), F.litPropertyMetadata ?? (F.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let yt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = Es) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && ka(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: r, set: n } = Ha(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get: r, set(o) {
      const c = r == null ? void 0 : r.call(this);
      n == null || n.call(this, o), this.requestUpdate(t, c, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? Es;
  }
  static _$Ei() {
    if (this.hasOwnProperty(re("elementProperties"))) return;
    const t = Ia(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(re("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(re("properties"))) {
      const e = this.properties, i = [...Ua(e), ...La(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, r] of e) this.elementProperties.set(i, r);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const r = this._$Eu(e, i);
      r !== void 0 && this._$Eh.set(r, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(As(r));
    } else t !== void 0 && e.push(As(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Pa(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) == null ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) == null ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    var n;
    const i = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, i);
    if (r !== void 0 && i.reflect === !0) {
      const o = (((n = i.converter) == null ? void 0 : n.toAttribute) !== void 0 ? i.converter : dr).toAttribute(e, i.type);
      this._$Em = t, o == null ? this.removeAttribute(r) : this.setAttribute(r, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var n, o;
    const i = this.constructor, r = i._$Eh.get(t);
    if (r !== void 0 && this._$Em !== r) {
      const c = i.getPropertyOptions(r), a = typeof c.converter == "function" ? { fromAttribute: c.converter } : ((n = c.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? c.converter : dr;
      this._$Em = r;
      const l = a.fromAttribute(e, c.type);
      this[r] = l ?? ((o = this._$Ej) == null ? void 0 : o.get(r)) ?? l, this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    var r;
    if (t !== void 0) {
      const n = this.constructor, o = this[t];
      if (i ?? (i = n.getPropertyOptions(t)), !((i.hasChanged ?? ho)(o, e) || i.useDefault && i.reflect && o === ((r = this._$Ej) == null ? void 0 : r.get(t)) && !this.hasAttribute(n._$Eu(t, i)))) return;
      this.C(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: r, wrapped: n }, o) {
    i && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t) && (this._$Ej.set(t, o ?? e ?? this[t]), n !== !0 || o !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), r === !0 && this._$Em !== t && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [n, o] of this._$Ep) this[n] = o;
        this._$Ep = void 0;
      }
      const r = this.constructor.elementProperties;
      if (r.size > 0) for (const [n, o] of r) {
        const { wrapped: c } = o, a = this[n];
        c !== !0 || this._$AL.has(n) || a === void 0 || this.C(n, void 0, o, a);
      }
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (i = this._$EO) == null || i.forEach((r) => {
        var n;
        return (n = r.hostUpdate) == null ? void 0 : n.call(r);
      }), this.update(e)) : this._$EM();
    } catch (r) {
      throw t = !1, this._$EM(), r;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) == null ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
yt.elementStyles = [], yt.shadowRootOptions = { mode: "open" }, yt[re("elementProperties")] = /* @__PURE__ */ new Map(), yt[re("finalized")] = /* @__PURE__ */ new Map(), vi == null || vi({ ReactiveElement: yt }), (F.reactiveElementVersions ?? (F.reactiveElementVersions = [])).push("2.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const se = globalThis, We = se.trustedTypes, Cs = We ? We.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, po = "$lit$", I = `lit$${Math.random().toFixed(9).slice(2)}$`, uo = "?" + I, Na = `<${uo}>`, ct = document, oe = () => ct.createComment(""), ae = (s) => s === null || typeof s != "object" && typeof s != "function", Fr = Array.isArray, Da = (s) => Fr(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", gi = `[ 	
\f\r]`, Xt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, ws = /-->/g, xs = />/g, K = RegExp(`>|${gi}(?:([^\\s"'>=/]+)(${gi}*=${gi}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Ts = /'/g, Rs = /"/g, fo = /^(?:script|style|textarea|title)$/i, za = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), g = za(1), Pt = Symbol.for("lit-noChange"), b = Symbol.for("lit-nothing"), Ps = /* @__PURE__ */ new WeakMap(), tt = ct.createTreeWalker(ct, 129);
function mo(s, t) {
  if (!Fr(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Cs !== void 0 ? Cs.createHTML(t) : t;
}
const Ba = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Xt;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === Xt ? h[1] === "!--" ? o = ws : h[1] !== void 0 ? o = xs : h[2] !== void 0 ? (fo.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = K) : h[3] !== void 0 && (o = K) : o === K ? h[0] === ">" ? (o = r ?? Xt, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? K : h[3] === '"' ? Rs : Ts) : o === Rs || o === Ts ? o = K : o === ws || o === xs ? o = Xt : (o = K, r = void 0);
    const u = o === K && s[c + 1].startsWith("/>") ? " " : "";
    n += o === Xt ? a + Na : d >= 0 ? (i.push(l), a.slice(0, d) + po + a.slice(d) + I + u) : a + I + (d === -2 ? c : u);
  }
  return [mo(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
};
let hr = class vo {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = Ba(t, e);
    if (this.el = vo.createElement(l, i), tt.currentNode = this.el.content, e === 2 || e === 3) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (r = tt.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) for (const d of r.getAttributeNames()) if (d.endsWith(po)) {
          const p = h[o++], u = r.getAttribute(d).split(I), v = /([.?@])?(.*)/.exec(p);
          a.push({ type: 1, index: n, name: v[2], strings: u, ctor: v[1] === "." ? Fa : v[1] === "?" ? Va : v[1] === "@" ? Wa : ni }), r.removeAttribute(d);
        } else d.startsWith(I) && (a.push({ type: 6, index: n }), r.removeAttribute(d));
        if (fo.test(r.tagName)) {
          const d = r.textContent.split(I), p = d.length - 1;
          if (p > 0) {
            r.textContent = We ? We.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], oe()), tt.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], oe());
          }
        }
      } else if (r.nodeType === 8) if (r.data === uo) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(I, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += I.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = ct.createElement("template");
    return i.innerHTML = t, i;
  }
};
function Ot(s, t, e = s, i) {
  var o, c;
  if (t === Pt) return t;
  let r = i !== void 0 ? (o = e._$Co) == null ? void 0 : o[i] : e._$Cl;
  const n = ae(t) ? void 0 : t._$litDirective$;
  return (r == null ? void 0 : r.constructor) !== n && ((c = r == null ? void 0 : r._$AO) == null || c.call(r, !1), n === void 0 ? r = void 0 : (r = new n(s), r._$AT(s, e, i)), i !== void 0 ? (e._$Co ?? (e._$Co = []))[i] = r : e._$Cl = r), r !== void 0 && (t = Ot(s, r._$AS(s, t.values), r, i)), t;
}
let ja = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, r = ((t == null ? void 0 : t.creationScope) ?? ct).importNode(e, !0);
    tt.currentNode = r;
    let n = tt.nextNode(), o = 0, c = 0, a = i[0];
    for (; a !== void 0; ) {
      if (o === a.index) {
        let l;
        a.type === 2 ? l = new Vr(n, n.nextSibling, this, t) : a.type === 1 ? l = new a.ctor(n, a.name, a.strings, this, t) : a.type === 6 && (l = new Ka(n, this, t)), this._$AV.push(l), a = i[++c];
      }
      o !== (a == null ? void 0 : a.index) && (n = tt.nextNode(), o++);
    }
    return tt.currentNode = ct, r;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, Vr = class go {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, i, r) {
    this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cv = (r == null ? void 0 : r.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Ot(this, t, e), ae(t) ? t === b || t == null || t === "" ? (this._$AH !== b && this._$AR(), this._$AH = b) : t !== this._$AH && t !== Pt && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Da(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== b && ae(this._$AH) ? this._$AA.nextSibling.data = t : this.T(ct.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var n;
    const { values: e, _$litType$: i } = t, r = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = hr.createElement(mo(i.h, i.h[0]), this.options)), i);
    if (((n = this._$AH) == null ? void 0 : n._$AD) === r) this._$AH.p(e);
    else {
      const o = new ja(r, this), c = o.u(this.options);
      o.p(e), this.T(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Ps.get(t.strings);
    return e === void 0 && Ps.set(t.strings, e = new hr(t)), e;
  }
  k(t) {
    Fr(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new go(this.O(oe()), this.O(oe()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, !1, !0, e); t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
}, ni = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = b;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = Ot(this, t, e, 0), o = !ae(t) || t !== this._$AH && t !== Pt, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = Ot(this, c[i + a], e, a), l === Pt && (l = this._$AH[a]), o || (o = !ae(l) || l !== this._$AH[a]), l === b ? t = b : t !== b && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, Fa = class extends ni {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === b ? void 0 : t;
  }
}, Va = class extends ni {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== b);
  }
}, Wa = class extends ni {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Ot(this, t, e, 0) ?? b) === Pt) return;
    const i = this._$AH, r = t === b && i !== b || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, n = t !== b && (i === b || r);
    r && this.element.removeEventListener(this.name, this, i), n && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, Ka = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Ot(this, t);
  }
};
const $i = se.litHtmlPolyfillSupport;
$i == null || $i(hr, Vr), (se.litHtmlVersions ?? (se.litHtmlVersions = [])).push("3.3.1");
const Ga = (s, t, e) => {
  const i = (e == null ? void 0 : e.renderBefore) ?? t;
  let r = i._$litPart$;
  if (r === void 0) {
    const n = (e == null ? void 0 : e.renderBefore) ?? null;
    i._$litPart$ = r = new Vr(t.insertBefore(oe(), n), n, void 0, e ?? {});
  }
  return r._$AI(s), r;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const at = globalThis;
let lt = class extends yt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Ga(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return Pt;
  }
};
var no;
lt._$litElement$ = !0, lt.finalized = !0, (no = at.litElementHydrateSupport) == null || no.call(at, { LitElement: lt });
const _i = at.litElementPolyfillSupport;
_i == null || _i({ LitElement: lt });
(at.litElementVersions ?? (at.litElementVersions = [])).push("4.2.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Wr = (s) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    customElements.define(s, t);
  }) : customElements.define(s, t);
}, Kr = si`
  :host {
    --primary-color: var(--primary-color, #1976d2);
    --text-primary-color: var(--primary-text-color, #212121);
    --text-secondary-color: var(--secondary-text-color, #757575);
    --divider-color: var(--divider-color, #e0e0e0);
    --card-background-color: var(--card-background-color, #ffffff);
    --disabled-color: var(--disabled-text-color, #9e9e9e);
    --success-color: var(--success-color, #4caf50);
    --error-color: var(--error-color, #f44336);
    --warning-color: var(--warning-color, #ff9800);

    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
    --spacing-xl: 32px;

    --border-radius: 4px;
    --transition-speed: 0.2s;
  }

  * {
    box-sizing: border-box;
  }

  .card {
    background: var(--card-background-color);
    border-radius: var(--border-radius);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    padding: var(--spacing-md);
  }

  .section-header {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    color: var(--text-secondary-color);
    margin: var(--spacing-lg) 0 var(--spacing-sm);
    letter-spacing: 0.5px;
  }

  .divider {
    height: 1px;
    background: var(--divider-color);
    margin: var(--spacing-md) 0;
  }

  .button {
    padding: var(--spacing-sm) var(--spacing-md);
    border: none;
    border-radius: var(--border-radius);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-speed);
  }

  .button-primary {
    background: var(--primary-color);
    color: white;
  }

  .button-primary:hover {
    opacity: 0.9;
  }

  .button-secondary {
    background: transparent;
    color: var(--primary-color);
    border: 1px solid var(--divider-color);
  }

  .button-secondary:hover {
    background: rgba(0, 0, 0, 0.05);
  }

  .icon-button {
    padding: var(--spacing-sm);
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-secondary-color);
    border-radius: var(--border-radius);
    transition: all var(--transition-speed);
  }

  .icon-button:hover {
    background: rgba(0, 0, 0, 0.05);
    color: var(--text-primary-color);
  }

  .text-muted {
    color: var(--text-secondary-color);
    font-size: 12px;
  }

  .error-text {
    color: var(--error-color);
    font-size: 12px;
    margin-top: var(--spacing-xs);
  }

  .loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--spacing-xl);
    color: var(--text-secondary-color);
  }

  .empty-state {
    text-align: center;
    padding: var(--spacing-xl);
    color: var(--text-secondary-color);
  }

  .empty-state-icon {
    font-size: 48px;
    opacity: 0.3;
    margin-bottom: var(--spacing-md);
  }
`;
var oo, ar, Hd;
oo = [Wr("ht-location-tree")];
let xt = class xt extends (Hd = lt) {
  constructor() {
    super(...arguments), this.locations = [], this._expandedIds = /* @__PURE__ */ new Set();
  }
  render() {
    if (this._error)
      return g`
        <div class="error-text">Error loading locations: ${this._error}</div>
      `;
    if (!this.locations.length)
      return g`
        <div class="empty-state">
          <div class="empty-state-icon">üìç</div>
          <div>No locations yet. Create your first location to get started.</div>
        </div>
      `;
    const t = this._getRootLocations();
    return g`
      <div class="tree-container">
        <div class="actions">
          <button class="button button-primary" @click=${this._handleCreate}>
            + New Location
          </button>
        </div>
        ${t.map((e) => this._renderNode(e))}
      </div>
    `;
  }
  _renderNode(t) {
    const e = this._getChildren(t.id), i = e.length > 0, r = this._expandedIds.has(t.id), n = this.selectedId === t.id;
    return g`
      <div>
        <div
          class="tree-node ${n ? "selected" : ""}"
          @click=${() => this._handleSelect(t.id)}
        >
          <div class="tree-node-content">
            <div
              class="expand-icon ${r ? "expanded" : ""} ${i ? "" : "placeholder"}"
              @click=${(o) => this._handleExpandToggle(o, t.id)}
            >
              ${i ? "‚ñ∂" : ""}
            </div>
            <div class="location-icon">
              ${this._getLocationIcon(t)}
            </div>
            <div class="location-name">${t.name}</div>
          </div>
        </div>
        ${i && r ? g`
              <div class="tree-children">
                ${e.map((o) => this._renderNode(o))}
              </div>
            ` : ""}
      </div>
    `;
  }
  _getRootLocations() {
    return this.locations.filter(
      (t) => t.parent_id === null || t.is_explicit_root
    );
  }
  _getChildren(t) {
    return this.locations.filter((e) => e.parent_id === t);
  }
  _getLocationIcon(t) {
    const e = t.modules._meta, i = (e == null ? void 0 : e.type) || "room";
    return {
      floor: "‚â°",
      room: "‚óé",
      zone: "‚óá",
      suite: "‚ùñ",
      outdoor: "‚åÇ",
      building: "‚ñ£"
    }[i] || "‚óé";
  }
  _handleExpandToggle(t, e) {
    t.stopPropagation();
    const i = new Set(this._expandedIds);
    i.has(e) ? i.delete(e) : i.add(e), this._expandedIds = i;
  }
  _handleSelect(t) {
    this.dispatchEvent(
      new CustomEvent("location-selected", {
        detail: { locationId: t },
        bubbles: !0,
        composed: !0
      })
    );
  }
  _handleCreate() {
    this.dispatchEvent(
      new CustomEvent("location-create", {
        bubbles: !0,
        composed: !0
      })
    );
  }
};
ar = xe(Hd), xt = Re(ar, 0, "HtLocationTree", oo, xt), xt.styles = [
  Kr,
  si`
      :host {
        display: block;
        height: 100%;
        overflow-y: auto;
      }

      .tree-container {
        padding: var(--spacing-md);
      }

      .tree-node {
        display: flex;
        align-items: center;
        padding: var(--spacing-sm) var(--spacing-md);
        cursor: pointer;
        border-radius: var(--border-radius);
        transition: background var(--transition-speed);
        user-select: none;
      }

      .tree-node:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      .tree-node.selected {
        background: var(--primary-color);
        color: white;
      }

      .tree-node.selected:hover {
        background: var(--primary-color);
        opacity: 0.9;
      }

      .tree-node-content {
        display: flex;
        align-items: center;
        flex: 1;
        gap: var(--spacing-sm);
      }

      .expand-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform var(--transition-speed);
      }

      .expand-icon.expanded {
        transform: rotate(90deg);
      }

      .expand-icon.placeholder {
        opacity: 0;
      }

      .location-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .location-name {
        flex: 1;
        font-size: 14px;
      }

      .tree-children {
        margin-left: var(--spacing-lg);
      }

      .actions {
        display: flex;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-md);
      }
    `
], Te(ar, 1, xt);
let Os = xt;
var pr = function(s, t) {
  return pr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
  }, pr(s, t);
};
function H(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  pr(s, t);
  function e() {
    this.constructor = s;
  }
  s.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var R = function() {
  return R = Object.assign || function(t) {
    for (var e, i = 1, r = arguments.length; i < r; i++) {
      e = arguments[i];
      for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    }
    return t;
  }, R.apply(this, arguments);
};
function f(s, t, e, i) {
  var r = arguments.length, n = r < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, e) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") n = Reflect.decorate(s, t, e, i);
  else for (var c = s.length - 1; c >= 0; c--) (o = s[c]) && (n = (r < 3 ? o(n) : r > 3 ? o(t, e, n) : o(t, e)) || n);
  return r > 3 && n && Object.defineProperty(t, e, n), n;
}
function Pe(s) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && s[t], i = 0;
  if (e) return e.call(s);
  if (s && typeof s.length == "number") return {
    next: function() {
      return s && i >= s.length && (s = void 0), { value: s && s[i++], done: !s };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function qa(s, t) {
  var e = typeof Symbol == "function" && s[Symbol.iterator];
  if (!e) return s;
  var i = e.call(s), r, n = [], o;
  try {
    for (; (t === void 0 || t-- > 0) && !(r = i.next()).done; ) n.push(r.value);
  } catch (c) {
    o = { error: c };
  } finally {
    try {
      r && !r.done && (e = i.return) && e.call(i);
    } finally {
      if (o) throw o.error;
    }
  }
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Xa = (s) => (t) => typeof t == "function" ? ((e, i) => (customElements.define(e, i), i))(s, t) : ((e, i) => {
  const { kind: r, elements: n } = i;
  return { kind: r, elements: n, finisher(o) {
    customElements.define(e, o);
  } };
})(s, t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Za = (s, t) => t.kind === "method" && t.descriptor && !("value" in t.descriptor) ? { ...t, finisher(e) {
  e.createProperty(t.key, s);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: t.key, initializer() {
  typeof t.initializer == "function" && (this[t.key] = t.initializer.call(this));
}, finisher(e) {
  e.createProperty(t.key, s);
} }, Ya = (s, t, e) => {
  t.constructor.createProperty(e, s);
};
function Ja(s) {
  return (t, e) => e !== void 0 ? Ya(s, t, e) : Za(s, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Qa = ({ finisher: s, descriptor: t }) => (e, i) => {
  var r;
  if (i === void 0) {
    const n = (r = e.originalKey) !== null && r !== void 0 ? r : e.key, o = t != null ? { kind: "method", placement: "prototype", key: n, descriptor: t(e.key) } : { ...e, key: n };
    return s != null && (o.finisher = function(c) {
      s(c, n);
    }), o;
  }
  {
    const n = e.constructor;
    t !== void 0 && Object.defineProperty(e, i, t(i)), s == null || s(n, i);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Gr(s, t) {
  return Qa({ descriptor: (e) => ({ get() {
    var r, n;
    return (n = (r = this.renderRoot) === null || r === void 0 ? void 0 : r.querySelector(s)) !== null && n !== void 0 ? n : null;
  }, enumerable: !0, configurable: !0 }) });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var yi;
((yi = window.HTMLSlotElement) === null || yi === void 0 ? void 0 : yi.prototype.assignedElements) != null;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tl = (s) => (t) => typeof t == "function" ? ((e, i) => (customElements.define(e, i), i))(s, t) : ((e, i) => {
  const { kind: r, elements: n } = i;
  return { kind: r, elements: n, finisher(o) {
    customElements.define(e, o);
  } };
})(s, t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const el = (s, t) => t.kind === "method" && t.descriptor && !("value" in t.descriptor) ? { ...t, finisher(e) {
  e.createProperty(t.key, s);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: t.key, initializer() {
  typeof t.initializer == "function" && (this[t.key] = t.initializer.call(this));
}, finisher(e) {
  e.createProperty(t.key, s);
} }, il = (s, t, e) => {
  t.constructor.createProperty(e, s);
};
function k(s) {
  return (t, e) => e !== void 0 ? il(s, t, e) : el(s, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function $o(s) {
  return k({ ...s, state: !0 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const qr = ({ finisher: s, descriptor: t }) => (e, i) => {
  var r;
  if (i === void 0) {
    const n = (r = e.originalKey) !== null && r !== void 0 ? r : e.key, o = t != null ? { kind: "method", placement: "prototype", key: n, descriptor: t(e.key) } : { ...e, key: n };
    return s != null && (o.finisher = function(c) {
      s(c, n);
    }), o;
  }
  {
    const n = e.constructor;
    t !== void 0 && Object.defineProperty(e, i, t(i)), s == null || s(n, i);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function rl(s) {
  return qr({ finisher: (t, e) => {
    Object.assign(t.prototype[e], s);
  } });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Xr(s, t) {
  return qr({ descriptor: (e) => ({ get() {
    var r, n;
    return (n = (r = this.renderRoot) === null || r === void 0 ? void 0 : r.querySelector(s)) !== null && n !== void 0 ? n : null;
  }, enumerable: !0, configurable: !0 }) });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function sl(s) {
  return qr({ descriptor: (t) => ({ async get() {
    var e;
    return await this.updateComplete, (e = this.renderRoot) === null || e === void 0 ? void 0 : e.querySelector(s);
  }, enumerable: !0, configurable: !0 }) });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var bi;
((bi = window.HTMLSlotElement) === null || bi === void 0 ? void 0 : bi.prototype.assignedElements) != null;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const nl = (s) => (t) => typeof t == "function" ? ((e, i) => (customElements.define(e, i), i))(s, t) : ((e, i) => {
  const { kind: r, elements: n } = i;
  return { kind: r, elements: n, finisher(o) {
    customElements.define(e, o);
  } };
})(s, t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ol = (s, t) => t.kind === "method" && t.descriptor && !("value" in t.descriptor) ? { ...t, finisher(e) {
  e.createProperty(t.key, s);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: t.key, initializer() {
  typeof t.initializer == "function" && (this[t.key] = t.initializer.call(this));
}, finisher(e) {
  e.createProperty(t.key, s);
} }, al = (s, t, e) => {
  t.constructor.createProperty(e, s);
};
function _o(s) {
  return (t, e) => e !== void 0 ? al(s, t, e) : ol(s, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ll = ({ finisher: s, descriptor: t }) => (e, i) => {
  var r;
  if (i === void 0) {
    const n = (r = e.originalKey) !== null && r !== void 0 ? r : e.key, o = t != null ? { kind: "method", placement: "prototype", key: n, descriptor: t(e.key) } : { ...e, key: n };
    return s != null && (o.finisher = function(c) {
      s(c, n);
    }), o;
  }
  {
    const n = e.constructor;
    t !== void 0 && Object.defineProperty(e, i, t(i)), s == null || s(n, i);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function yo(s, t) {
  return ll({ descriptor: (e) => ({ get() {
    var r, n;
    return (n = (r = this.renderRoot) === null || r === void 0 ? void 0 : r.querySelector(s)) !== null && n !== void 0 ? n : null;
  }, enumerable: !0, configurable: !0 }) });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Ai;
((Ai = window.HTMLSlotElement) === null || Ai === void 0 ? void 0 : Ai.prototype.assignedElements) != null;
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ue = window, Zr = Ue.ShadowRoot && (Ue.ShadyCSS === void 0 || Ue.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, bo = Symbol(), ks = /* @__PURE__ */ new WeakMap();
let cl = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== bo) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Zr && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = ks.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && ks.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const dl = (s) => new cl(typeof s == "string" ? s : s + "", void 0, bo), hl = (s, t) => {
  Zr ? s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach((e) => {
    const i = document.createElement("style"), r = Ue.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  });
}, Hs = Zr ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return dl(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Si;
const Ke = window, Us = Ke.trustedTypes, pl = Us ? Us.emptyScript : "", Ls = Ke.reactiveElementPolyfillSupport, ur = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? pl : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, Ao = (s, t) => t !== s && (t == t || s == s), Ei = { attribute: !0, type: String, converter: ur, reflect: !1, hasChanged: Ao }, fr = "finalized";
let bt = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(t) {
    var e;
    this.finalize(), ((e = this.h) !== null && e !== void 0 ? e : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((e, i) => {
      const r = this._$Ep(i, e);
      r !== void 0 && (this._$Ev.set(r, i), t.push(r));
    }), t;
  }
  static createProperty(t, e = Ei) {
    if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const i = typeof t == "symbol" ? Symbol() : "__" + t, r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && Object.defineProperty(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return { get() {
      return this[e];
    }, set(r) {
      const n = this[t];
      this[e] = r, this.requestUpdate(t, n, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || Ei;
  }
  static finalize() {
    if (this.hasOwnProperty(fr)) return !1;
    this[fr] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e = this.properties, i = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(Hs(r));
    } else t !== void 0 && e.push(Hs(t));
    return e;
  }
  static _$Ep(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  _$Eu() {
    var t;
    this._$E_ = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((e) => e(this));
  }
  addController(t) {
    var e, i;
    ((e = this._$ES) !== null && e !== void 0 ? e : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) === null || i === void 0 || i.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return hl(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EO(t, e, i = Ei) {
    var r;
    const n = this.constructor._$Ep(t, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) === null || r === void 0 ? void 0 : r.toAttribute) !== void 0 ? i.converter : ur).toAttribute(e, i.type);
      this._$El = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null;
    }
  }
  _$AK(t, e) {
    var i;
    const r = this.constructor, n = r._$Ev.get(t);
    if (n !== void 0 && this._$El !== n) {
      const o = r.getPropertyOptions(n), c = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? o.converter : ur;
      this._$El = n, this[n] = c.fromAttribute(e, o.type), this._$El = null;
    }
  }
  requestUpdate(t, e, i) {
    let r = !0;
    t !== void 0 && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || Ao)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, i))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((r, n) => this[n] = r), this._$Ei = void 0);
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
        var n;
        return (n = r.hostUpdate) === null || n === void 0 ? void 0 : n.call(r);
      }), this.update(i)) : this._$Ek();
    } catch (r) {
      throw e = !1, this._$Ek(), r;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) === null || r === void 0 ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((e, i) => this._$EO(i, this[i], e)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
bt[fr] = !0, bt.elementProperties = /* @__PURE__ */ new Map(), bt.elementStyles = [], bt.shadowRootOptions = { mode: "open" }, Ls == null || Ls({ ReactiveElement: bt }), ((Si = Ke.reactiveElementVersions) !== null && Si !== void 0 ? Si : Ke.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Ci;
const Ge = window, kt = Ge.trustedTypes, Is = kt ? kt.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, mr = "$lit$", M = `lit$${(Math.random() + "").slice(9)}$`, So = "?" + M, ul = `<${So}>`, dt = document, le = () => dt.createComment(""), ce = (s) => s === null || typeof s != "object" && typeof s != "function", Eo = Array.isArray, fl = (s) => Eo(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", wi = `[ 	
\f\r]`, Zt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Ms = /-->/g, Ns = />/g, G = RegExp(`>|${wi}(?:([^\\s"'>=/]+)(${wi}*=${wi}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Ds = /'/g, zs = /"/g, Co = /^(?:script|style|textarea|title)$/i, Ht = Symbol.for("lit-noChange"), A = Symbol.for("lit-nothing"), Bs = /* @__PURE__ */ new WeakMap(), et = dt.createTreeWalker(dt, 129, null, !1);
function wo(s, t) {
  if (!Array.isArray(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Is !== void 0 ? Is.createHTML(t) : t;
}
const ml = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : "", o = Zt;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === Zt ? h[1] === "!--" ? o = Ms : h[1] !== void 0 ? o = Ns : h[2] !== void 0 ? (Co.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = G) : h[3] !== void 0 && (o = G) : o === G ? h[0] === ">" ? (o = r ?? Zt, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? G : h[3] === '"' ? zs : Ds) : o === zs || o === Ds ? o = G : o === Ms || o === Ns ? o = Zt : (o = G, r = void 0);
    const u = o === G && s[c + 1].startsWith("/>") ? " " : "";
    n += o === Zt ? a + ul : d >= 0 ? (i.push(l), a.slice(0, d) + mr + a.slice(d) + M + u) : a + M + (d === -2 ? (i.push(void 0), c) : u);
  }
  return [wo(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : "")), i];
};
let vr = class xo {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = ml(t, e);
    if (this.el = xo.createElement(l, i), et.currentNode = this.el.content, e === 2) {
      const d = this.el.content, p = d.firstChild;
      p.remove(), d.append(...p.childNodes);
    }
    for (; (r = et.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) {
          const d = [];
          for (const p of r.getAttributeNames()) if (p.endsWith(mr) || p.startsWith(M)) {
            const u = h[o++];
            if (d.push(p), u !== void 0) {
              const v = r.getAttribute(u.toLowerCase() + mr).split(M), m = /([.?@])?(.*)/.exec(u);
              a.push({ type: 1, index: n, name: m[2], strings: v, ctor: m[1] === "." ? gl : m[1] === "?" ? _l : m[1] === "@" ? yl : oi });
            } else a.push({ type: 6, index: n });
          }
          for (const p of d) r.removeAttribute(p);
        }
        if (Co.test(r.tagName)) {
          const d = r.textContent.split(M), p = d.length - 1;
          if (p > 0) {
            r.textContent = kt ? kt.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], le()), et.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], le());
          }
        }
      } else if (r.nodeType === 8) if (r.data === So) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(M, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += M.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = dt.createElement("template");
    return i.innerHTML = t, i;
  }
};
function Ut(s, t, e = s, i) {
  var r, n, o, c;
  if (t === Ht) return t;
  let a = i !== void 0 ? (r = e._$Co) === null || r === void 0 ? void 0 : r[i] : e._$Cl;
  const l = ce(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== l && ((n = a == null ? void 0 : a._$AO) === null || n === void 0 || n.call(a, !1), l === void 0 ? a = void 0 : (a = new l(s), a._$AT(s, e, i)), i !== void 0 ? ((o = (c = e)._$Co) !== null && o !== void 0 ? o : c._$Co = [])[i] = a : e._$Cl = a), a !== void 0 && (t = Ut(s, a._$AS(s, t.values), a, i)), t;
}
let vl = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var e;
    const { el: { content: i }, parts: r } = this._$AD, n = ((e = t == null ? void 0 : t.creationScope) !== null && e !== void 0 ? e : dt).importNode(i, !0);
    et.currentNode = n;
    let o = et.nextNode(), c = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (c === l.index) {
        let h;
        l.type === 2 ? h = new Yr(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new bl(o, this, t)), this._$AV.push(h), l = r[++a];
      }
      c !== (l == null ? void 0 : l.index) && (o = et.nextNode(), c++);
    }
    return et.currentNode = dt, n;
  }
  v(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, Yr = class To {
  constructor(t, e, i, r) {
    var n;
    this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cp = (n = r == null ? void 0 : r.isConnected) === null || n === void 0 || n;
  }
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && e !== void 0 ? e : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Ut(this, t, e), ce(t) ? t === A || t == null || t === "" ? (this._$AH !== A && this._$AR(), this._$AH = A) : t !== this._$AH && t !== Ht && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : fl(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== A && ce(this._$AH) ? this._$AA.nextSibling.data = t : this.$(dt.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var e;
    const { values: i, _$litType$: r } = t, n = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = vr.createElement(wo(r.h, r.h[0]), this.options)), r);
    if (((e = this._$AH) === null || e === void 0 ? void 0 : e._$AD) === n) this._$AH.v(i);
    else {
      const o = new vl(n, this), c = o.u(this.options);
      o.v(i), this.$(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Bs.get(t.strings);
    return e === void 0 && Bs.set(t.strings, e = new vr(t)), e;
  }
  T(t) {
    Eo(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new To(this.k(le()), this.k(le()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cp = t, (e = this._$AP) === null || e === void 0 || e.call(this, t));
  }
}, oi = class {
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = A;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = Ut(this, t, e, 0), o = !ce(t) || t !== this._$AH && t !== Ht, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = Ut(this, c[i + a], e, a), l === Ht && (l = this._$AH[a]), o || (o = !ce(l) || l !== this._$AH[a]), l === A ? t = A : t !== A && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, gl = class extends oi {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === A ? void 0 : t;
  }
};
const $l = kt ? kt.emptyScript : "";
let _l = class extends oi {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== A ? this.element.setAttribute(this.name, $l) : this.element.removeAttribute(this.name);
  }
}, yl = class extends oi {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    var i;
    if ((t = (i = Ut(this, t, e, 0)) !== null && i !== void 0 ? i : A) === Ht) return;
    const r = this._$AH, n = t === A && r !== A || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== A && (r === A || n);
    n && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, i;
    typeof this._$AH == "function" ? this._$AH.call((i = (e = this.options) === null || e === void 0 ? void 0 : e.host) !== null && i !== void 0 ? i : this.element, t) : this._$AH.handleEvent(t);
  }
}, bl = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Ut(this, t);
  }
};
const js = Ge.litHtmlPolyfillSupport;
js == null || js(vr, Yr), ((Ci = Ge.litHtmlVersions) !== null && Ci !== void 0 ? Ci : Ge.litHtmlVersions = []).push("2.8.0");
const Al = (s, t, e) => {
  var i, r;
  const n = (i = e == null ? void 0 : e.renderBefore) !== null && i !== void 0 ? i : t;
  let o = n._$litPart$;
  if (o === void 0) {
    const c = (r = e == null ? void 0 : e.renderBefore) !== null && r !== void 0 ? r : null;
    n._$litPart$ = o = new Yr(t.insertBefore(le(), c), c, void 0, e ?? {});
  }
  return o._$AI(s), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var xi, Ti;
let ne = class extends bt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (t = (e = this.renderOptions).renderBefore) !== null && t !== void 0 || (e.renderBefore = i.firstChild), i;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Al(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return Ht;
  }
};
ne.finalized = !0, ne._$litElement$ = !0, (xi = globalThis.litElementHydrateSupport) === null || xi === void 0 || xi.call(globalThis, { LitElement: ne });
const Fs = globalThis.litElementPolyfillSupport;
Fs == null || Fs({ LitElement: ne });
((Ti = globalThis.litElementVersions) !== null && Ti !== void 0 ? Ti : globalThis.litElementVersions = []).push("3.3.3");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Jr(s) {
  return {
    addClass: (t) => {
      s.classList.add(t);
    },
    removeClass: (t) => {
      s.classList.remove(t);
    },
    hasClass: (t) => s.classList.contains(t)
  };
}
const Ro = () => {
}, Sl = {
  get passive() {
    return !1;
  }
};
document.addEventListener("x", Ro, Sl);
document.removeEventListener("x", Ro);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class be extends ne {
  click() {
    if (this.mdcRoot) {
      this.mdcRoot.focus(), this.mdcRoot.click();
      return;
    }
    super.click();
  }
  /**
   * Create and attach the MDC Foundation to the instance
   */
  createFoundation() {
    this.mdcFoundation !== void 0 && this.mdcFoundation.destroy(), this.mdcFoundationClass && (this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter()), this.mdcFoundation.init());
  }
  firstUpdated() {
    this.createFoundation();
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Ae = (
  /** @class */
  function() {
    function s(t) {
      t === void 0 && (t = {}), this.adapter = t;
    }
    return Object.defineProperty(s, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s, "strings", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s, "numbers", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), s.prototype.init = function() {
    }, s.prototype.destroy = function() {
    }, s;
  }()
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var El = {
  ACTIVE: "mdc-tab-indicator--active",
  FADE: "mdc-tab-indicator--fade",
  NO_TRANSITION: "mdc-tab-indicator--no-transition"
}, Cl = {
  CONTENT_SELECTOR: ".mdc-tab-indicator__content"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var L = (
  /** @class */
  function(s) {
    H(t, s);
    function t(e) {
      return s.call(this, R(R({}, t.defaultAdapter), e)) || this;
    }
    return Object.defineProperty(t, "cssClasses", {
      get: function() {
        return El;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "strings", {
      get: function() {
        return Cl;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          computeContentClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          setContentStyleProperty: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.computeContentClientRect = function() {
      return this.adapter.computeContentClientRect();
    }, t;
  }(Ae)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var wl = (
  /** @class */
  function(s) {
    H(t, s);
    function t() {
      return s !== null && s.apply(this, arguments) || this;
    }
    return t.prototype.activate = function() {
      this.adapter.addClass(L.cssClasses.ACTIVE);
    }, t.prototype.deactivate = function() {
      this.adapter.removeClass(L.cssClasses.ACTIVE);
    }, t;
  }(L)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var xl = (
  /** @class */
  function(s) {
    H(t, s);
    function t() {
      return s !== null && s.apply(this, arguments) || this;
    }
    return t.prototype.activate = function(e) {
      if (!e) {
        this.adapter.addClass(L.cssClasses.ACTIVE);
        return;
      }
      var i = this.computeContentClientRect(), r = e.width / i.width, n = e.left - i.left;
      this.adapter.addClass(L.cssClasses.NO_TRANSITION), this.adapter.setContentStyleProperty("transform", "translateX(" + n + "px) scaleX(" + r + ")"), this.computeContentClientRect(), this.adapter.removeClass(L.cssClasses.NO_TRANSITION), this.adapter.addClass(L.cssClasses.ACTIVE), this.adapter.setContentStyleProperty("transform", "");
    }, t.prototype.deactivate = function() {
      this.adapter.removeClass(L.cssClasses.ACTIVE);
    }, t;
  }(L)
);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Le = window, Qr = Le.ShadowRoot && (Le.ShadyCSS === void 0 || Le.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, ts = Symbol(), Vs = /* @__PURE__ */ new WeakMap();
let Po = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== ts) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Qr && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = Vs.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && Vs.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Tl = (s) => new Po(typeof s == "string" ? s : s + "", void 0, ts), Rl = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new Po(e, s, ts);
}, Pl = (s, t) => {
  Qr ? s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach((e) => {
    const i = document.createElement("style"), r = Le.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  });
}, Ws = Qr ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return Tl(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Ri;
const qe = window, Ks = qe.trustedTypes, Ol = Ks ? Ks.emptyScript : "", Gs = qe.reactiveElementPolyfillSupport, gr = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? Ol : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, Oo = (s, t) => t !== s && (t == t || s == s), Pi = { attribute: !0, type: String, converter: gr, reflect: !1, hasChanged: Oo }, $r = "finalized";
let At = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(t) {
    var e;
    this.finalize(), ((e = this.h) !== null && e !== void 0 ? e : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((e, i) => {
      const r = this._$Ep(i, e);
      r !== void 0 && (this._$Ev.set(r, i), t.push(r));
    }), t;
  }
  static createProperty(t, e = Pi) {
    if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const i = typeof t == "symbol" ? Symbol() : "__" + t, r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && Object.defineProperty(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return { get() {
      return this[e];
    }, set(r) {
      const n = this[t];
      this[e] = r, this.requestUpdate(t, n, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || Pi;
  }
  static finalize() {
    if (this.hasOwnProperty($r)) return !1;
    this[$r] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e = this.properties, i = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(Ws(r));
    } else t !== void 0 && e.push(Ws(t));
    return e;
  }
  static _$Ep(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  _$Eu() {
    var t;
    this._$E_ = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((e) => e(this));
  }
  addController(t) {
    var e, i;
    ((e = this._$ES) !== null && e !== void 0 ? e : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) === null || i === void 0 || i.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return Pl(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EO(t, e, i = Pi) {
    var r;
    const n = this.constructor._$Ep(t, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) === null || r === void 0 ? void 0 : r.toAttribute) !== void 0 ? i.converter : gr).toAttribute(e, i.type);
      this._$El = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null;
    }
  }
  _$AK(t, e) {
    var i;
    const r = this.constructor, n = r._$Ev.get(t);
    if (n !== void 0 && this._$El !== n) {
      const o = r.getPropertyOptions(n), c = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? o.converter : gr;
      this._$El = n, this[n] = c.fromAttribute(e, o.type), this._$El = null;
    }
  }
  requestUpdate(t, e, i) {
    let r = !0;
    t !== void 0 && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || Oo)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, i))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((r, n) => this[n] = r), this._$Ei = void 0);
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
        var n;
        return (n = r.hostUpdate) === null || n === void 0 ? void 0 : n.call(r);
      }), this.update(i)) : this._$Ek();
    } catch (r) {
      throw e = !1, this._$Ek(), r;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) === null || r === void 0 ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((e, i) => this._$EO(i, this[i], e)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
At[$r] = !0, At.elementProperties = /* @__PURE__ */ new Map(), At.elementStyles = [], At.shadowRootOptions = { mode: "open" }, Gs == null || Gs({ ReactiveElement: At }), ((Ri = qe.reactiveElementVersions) !== null && Ri !== void 0 ? Ri : qe.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Oi;
const Xe = window, Lt = Xe.trustedTypes, qs = Lt ? Lt.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, _r = "$lit$", N = `lit$${(Math.random() + "").slice(9)}$`, ko = "?" + N, kl = `<${ko}>`, ht = document, de = () => ht.createComment(""), he = (s) => s === null || typeof s != "object" && typeof s != "function", Ho = Array.isArray, Hl = (s) => Ho(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", ki = `[ 	
\f\r]`, Yt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Xs = /-->/g, Zs = />/g, q = RegExp(`>|${ki}(?:([^\\s"'>=/]+)(${ki}*=${ki}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Ys = /'/g, Js = /"/g, Uo = /^(?:script|style|textarea|title)$/i, Ul = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), Ll = Ul(1), pt = Symbol.for("lit-noChange"), S = Symbol.for("lit-nothing"), Qs = /* @__PURE__ */ new WeakMap(), it = ht.createTreeWalker(ht, 129, null, !1);
function Lo(s, t) {
  if (!Array.isArray(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return qs !== void 0 ? qs.createHTML(t) : t;
}
const Il = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : "", o = Yt;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === Yt ? h[1] === "!--" ? o = Xs : h[1] !== void 0 ? o = Zs : h[2] !== void 0 ? (Uo.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = q) : h[3] !== void 0 && (o = q) : o === q ? h[0] === ">" ? (o = r ?? Yt, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? q : h[3] === '"' ? Js : Ys) : o === Js || o === Ys ? o = q : o === Xs || o === Zs ? o = Yt : (o = q, r = void 0);
    const u = o === q && s[c + 1].startsWith("/>") ? " " : "";
    n += o === Yt ? a + kl : d >= 0 ? (i.push(l), a.slice(0, d) + _r + a.slice(d) + N + u) : a + N + (d === -2 ? (i.push(void 0), c) : u);
  }
  return [Lo(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : "")), i];
};
let yr = class Io {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = Il(t, e);
    if (this.el = Io.createElement(l, i), it.currentNode = this.el.content, e === 2) {
      const d = this.el.content, p = d.firstChild;
      p.remove(), d.append(...p.childNodes);
    }
    for (; (r = it.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) {
          const d = [];
          for (const p of r.getAttributeNames()) if (p.endsWith(_r) || p.startsWith(N)) {
            const u = h[o++];
            if (d.push(p), u !== void 0) {
              const v = r.getAttribute(u.toLowerCase() + _r).split(N), m = /([.?@])?(.*)/.exec(u);
              a.push({ type: 1, index: n, name: m[2], strings: v, ctor: m[1] === "." ? Nl : m[1] === "?" ? zl : m[1] === "@" ? Bl : ai });
            } else a.push({ type: 6, index: n });
          }
          for (const p of d) r.removeAttribute(p);
        }
        if (Uo.test(r.tagName)) {
          const d = r.textContent.split(N), p = d.length - 1;
          if (p > 0) {
            r.textContent = Lt ? Lt.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], de()), it.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], de());
          }
        }
      } else if (r.nodeType === 8) if (r.data === ko) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(N, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += N.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = ht.createElement("template");
    return i.innerHTML = t, i;
  }
};
function It(s, t, e = s, i) {
  var r, n, o, c;
  if (t === pt) return t;
  let a = i !== void 0 ? (r = e._$Co) === null || r === void 0 ? void 0 : r[i] : e._$Cl;
  const l = he(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== l && ((n = a == null ? void 0 : a._$AO) === null || n === void 0 || n.call(a, !1), l === void 0 ? a = void 0 : (a = new l(s), a._$AT(s, e, i)), i !== void 0 ? ((o = (c = e)._$Co) !== null && o !== void 0 ? o : c._$Co = [])[i] = a : e._$Cl = a), a !== void 0 && (t = It(s, a._$AS(s, t.values), a, i)), t;
}
let Ml = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var e;
    const { el: { content: i }, parts: r } = this._$AD, n = ((e = t == null ? void 0 : t.creationScope) !== null && e !== void 0 ? e : ht).importNode(i, !0);
    it.currentNode = n;
    let o = it.nextNode(), c = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (c === l.index) {
        let h;
        l.type === 2 ? h = new es(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new jl(o, this, t)), this._$AV.push(h), l = r[++a];
      }
      c !== (l == null ? void 0 : l.index) && (o = it.nextNode(), c++);
    }
    return it.currentNode = ht, n;
  }
  v(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, es = class Mo {
  constructor(t, e, i, r) {
    var n;
    this.type = 2, this._$AH = S, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cp = (n = r == null ? void 0 : r.isConnected) === null || n === void 0 || n;
  }
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && e !== void 0 ? e : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = It(this, t, e), he(t) ? t === S || t == null || t === "" ? (this._$AH !== S && this._$AR(), this._$AH = S) : t !== this._$AH && t !== pt && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : Hl(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== S && he(this._$AH) ? this._$AA.nextSibling.data = t : this.$(ht.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var e;
    const { values: i, _$litType$: r } = t, n = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = yr.createElement(Lo(r.h, r.h[0]), this.options)), r);
    if (((e = this._$AH) === null || e === void 0 ? void 0 : e._$AD) === n) this._$AH.v(i);
    else {
      const o = new Ml(n, this), c = o.u(this.options);
      o.v(i), this.$(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Qs.get(t.strings);
    return e === void 0 && Qs.set(t.strings, e = new yr(t)), e;
  }
  T(t) {
    Ho(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new Mo(this.k(de()), this.k(de()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cp = t, (e = this._$AP) === null || e === void 0 || e.call(this, t));
  }
}, ai = class {
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = S, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = S;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = It(this, t, e, 0), o = !he(t) || t !== this._$AH && t !== pt, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = It(this, c[i + a], e, a), l === pt && (l = this._$AH[a]), o || (o = !he(l) || l !== this._$AH[a]), l === S ? t = S : t !== S && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === S ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, Nl = class extends ai {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === S ? void 0 : t;
  }
};
const Dl = Lt ? Lt.emptyScript : "";
let zl = class extends ai {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== S ? this.element.setAttribute(this.name, Dl) : this.element.removeAttribute(this.name);
  }
}, Bl = class extends ai {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    var i;
    if ((t = (i = It(this, t, e, 0)) !== null && i !== void 0 ? i : S) === pt) return;
    const r = this._$AH, n = t === S && r !== S || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== S && (r === S || n);
    n && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, i;
    typeof this._$AH == "function" ? this._$AH.call((i = (e = this.options) === null || e === void 0 ? void 0 : e.host) !== null && i !== void 0 ? i : this.element, t) : this._$AH.handleEvent(t);
  }
}, jl = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    It(this, t);
  }
};
const tn = Xe.litHtmlPolyfillSupport;
tn == null || tn(yr, es), ((Oi = Xe.litHtmlVersions) !== null && Oi !== void 0 ? Oi : Xe.litHtmlVersions = []).push("2.8.0");
const Fl = (s, t, e) => {
  var i, r;
  const n = (i = e == null ? void 0 : e.renderBefore) !== null && i !== void 0 ? i : t;
  let o = n._$litPart$;
  if (o === void 0) {
    const c = (r = e == null ? void 0 : e.renderBefore) !== null && r !== void 0 ? r : null;
    n._$litPart$ = o = new es(t.insertBefore(de(), c), c, void 0, e ?? {});
  }
  return o._$AI(s), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Hi, Ui;
let Ie = class extends At {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (t = (e = this.renderOptions).renderBefore) !== null && t !== void 0 || (e.renderBefore = i.firstChild), i;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Fl(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return pt;
  }
};
Ie.finalized = !0, Ie._$litElement$ = !0, (Hi = globalThis.litElementHydrateSupport) === null || Hi === void 0 || Hi.call(globalThis, { LitElement: Ie });
const en = globalThis.litElementPolyfillSupport;
en == null || en({ LitElement: Ie });
((Ui = globalThis.litElementVersions) !== null && Ui !== void 0 ? Ui : globalThis.litElementVersions = []).push("3.3.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Vl = { ATTRIBUTE: 1 }, Wl = (s) => (...t) => ({ _$litDirective$: s, values: t });
let Kl = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rn = Wl(class extends Kl {
  constructor(s) {
    var t;
    if (super(s), s.type !== Vl.ATTRIBUTE || s.name !== "class" || ((t = s.strings) === null || t === void 0 ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return " " + Object.keys(s).filter((t) => s[t]).join(" ") + " ";
  }
  update(s, [t]) {
    var e, i;
    if (this.it === void 0) {
      this.it = /* @__PURE__ */ new Set(), s.strings !== void 0 && (this.nt = new Set(s.strings.join(" ").split(/\s/).filter((n) => n !== "")));
      for (const n in t) t[n] && !(!((e = this.nt) === null || e === void 0) && e.has(n)) && this.it.add(n);
      return this.render(t);
    }
    const r = s.element.classList;
    this.it.forEach((n) => {
      n in t || (r.remove(n), this.it.delete(n));
    });
    for (const n in t) {
      const o = !!t[n];
      o === this.it.has(n) || !((i = this.nt) === null || i === void 0) && i.has(n) || (o ? (r.add(n), this.it.add(n)) : (r.remove(n), this.it.delete(n)));
    }
    return pt;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Se extends be {
  constructor() {
    super(...arguments), this.icon = "", this.fade = !1;
  }
  get mdcFoundationClass() {
    return this.fade ? wl : xl;
  }
  render() {
    const t = {
      "mdc-tab-indicator__content--icon": this.icon,
      "material-icons": this.icon,
      "mdc-tab-indicator__content--underline": !this.icon
    };
    return Ll`
      <span class="mdc-tab-indicator ${rn({
      "mdc-tab-indicator--fade": this.fade
    })}">
        <span class="mdc-tab-indicator__content ${rn(t)}">${this.icon}</span>
      </span>
      `;
  }
  updated(t) {
    t.has("fade") && this.createFoundation();
  }
  createAdapter() {
    return Object.assign(Object.assign({}, Jr(this.mdcRoot)), { computeContentClientRect: () => this.contentElement.getBoundingClientRect(), setContentStyleProperty: (t, e) => this.contentElement.style.setProperty(t, e) });
  }
  computeContentClientRect() {
    return this.mdcFoundation.computeContentClientRect();
  }
  activate(t) {
    this.mdcFoundation.activate(t);
  }
  deactivate() {
    this.mdcFoundation.deactivate();
  }
}
f([
  yo(".mdc-tab-indicator")
], Se.prototype, "mdcRoot", void 0);
f([
  yo(".mdc-tab-indicator__content")
], Se.prototype, "contentElement", void 0);
f([
  _o()
], Se.prototype, "icon", void 0);
f([
  _o({ type: Boolean })
], Se.prototype, "fade", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const Gl = Rl`.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}.mdc-tab-indicator .mdc-tab-indicator__content--underline{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-tab-indicator .mdc-tab-indicator__content--icon{color:#018786;color:var(--mdc-theme-secondary, #018786)}.mdc-tab-indicator .mdc-tab-indicator__content--underline{border-top-width:2px}.mdc-tab-indicator .mdc-tab-indicator__content--icon{height:34px;font-size:34px}.mdc-tab-indicator{display:flex;position:absolute;top:0;left:0;justify-content:center;width:100%;height:100%;pointer-events:none;z-index:1}.mdc-tab-indicator__content{transform-origin:left;opacity:0}.mdc-tab-indicator__content--underline{align-self:flex-end;box-sizing:border-box;width:100%;border-top-style:solid}.mdc-tab-indicator__content--icon{align-self:center;margin:0 auto}.mdc-tab-indicator--active .mdc-tab-indicator__content{opacity:1}.mdc-tab-indicator .mdc-tab-indicator__content{transition:250ms transform cubic-bezier(0.4, 0, 0.2, 1)}.mdc-tab-indicator--no-transition .mdc-tab-indicator__content{transition:none}.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition:150ms opacity linear}.mdc-tab-indicator--active.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition-delay:100ms}`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let br = class extends Se {
};
br.styles = [Gl];
br = f([
  nl("mwc-tab-indicator")
], br);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ql = (s) => (t) => typeof t == "function" ? ((e, i) => (customElements.define(e, i), i))(s, t) : ((e, i) => {
  const { kind: r, elements: n } = i;
  return { kind: r, elements: n, finisher(o) {
    customElements.define(e, o);
  } };
})(s, t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Xl = (s, t) => t.kind === "method" && t.descriptor && !("value" in t.descriptor) ? { ...t, finisher(e) {
  e.createProperty(t.key, s);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: t.key, initializer() {
  typeof t.initializer == "function" && (this[t.key] = t.initializer.call(this));
}, finisher(e) {
  e.createProperty(t.key, s);
} }, Zl = (s, t, e) => {
  t.constructor.createProperty(e, s);
};
function W(s) {
  return (t, e) => e !== void 0 ? Zl(s, t, e) : Xl(s, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function U(s) {
  return W({ ...s, state: !0 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Yl = ({ finisher: s, descriptor: t }) => (e, i) => {
  var r;
  if (i === void 0) {
    const n = (r = e.originalKey) !== null && r !== void 0 ? r : e.key, o = t != null ? { kind: "method", placement: "prototype", key: n, descriptor: t(e.key) } : { ...e, key: n };
    return s != null && (o.finisher = function(c) {
      s(c, n);
    }), o;
  }
  {
    const n = e.constructor;
    t !== void 0 && Object.defineProperty(e, i, t(i)), s == null || s(n, i);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Jl(s, t) {
  return Yl({ descriptor: (e) => ({ get() {
    var r, n;
    return (n = (r = this.renderRoot) === null || r === void 0 ? void 0 : r.querySelector(s)) !== null && n !== void 0 ? n : null;
  }, enumerable: !0, configurable: !0 }) });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Li;
((Li = window.HTMLSlotElement) === null || Li === void 0 ? void 0 : Li.prototype.assignedElements) != null;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function No(s, t) {
  var e = s.matches || s.webkitMatchesSelector || s.msMatchesSelector;
  return e.call(s, t);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Ql = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
}, tc = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
}, sn = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
  // Delay between touch and simulated mouse events on touch devices
};
function ec(s, t, e) {
  if (!s)
    return { x: 0, y: 0 };
  var i = t.x, r = t.y, n = i + e.left, o = r + e.top, c, a;
  if (s.type === "touchstart") {
    var l = s;
    c = l.changedTouches[0].pageX - n, a = l.changedTouches[0].pageY - o;
  } else {
    var h = s;
    c = h.pageX - n, a = h.pageY - o;
  }
  return { x: c, y: a };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var nn = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
], on = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
], Oe = [], ic = (
  /** @class */
  function(s) {
    H(t, s);
    function t(e) {
      var i = s.call(this, R(R({}, t.defaultAdapter), e)) || this;
      return i.activationAnimationHasEnded = !1, i.activationTimer = 0, i.fgDeactivationRemovalTimer = 0, i.fgScale = "0", i.frame = { width: 0, height: 0 }, i.initialSize = 0, i.layoutFrame = 0, i.maxRadius = 0, i.unboundedCoords = { left: 0, top: 0 }, i.activationState = i.defaultActivationState(), i.activationTimerCallback = function() {
        i.activationAnimationHasEnded = !0, i.runDeactivationUXLogicIfReady();
      }, i.activateHandler = function(r) {
        i.activateImpl(r);
      }, i.deactivateHandler = function() {
        i.deactivateImpl();
      }, i.focusHandler = function() {
        i.handleFocus();
      }, i.blurHandler = function() {
        i.handleBlur();
      }, i.resizeHandler = function() {
        i.layout();
      }, i;
    }
    return Object.defineProperty(t, "cssClasses", {
      get: function() {
        return Ql;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "strings", {
      get: function() {
        return tc;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "numbers", {
      get: function() {
        return sn;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          browserSupportsCssVars: function() {
            return !0;
          },
          computeBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          containsEventTarget: function() {
            return !0;
          },
          deregisterDocumentInteractionHandler: function() {
          },
          deregisterInteractionHandler: function() {
          },
          deregisterResizeHandler: function() {
          },
          getWindowPageOffset: function() {
            return { x: 0, y: 0 };
          },
          isSurfaceActive: function() {
            return !0;
          },
          isSurfaceDisabled: function() {
            return !0;
          },
          isUnbounded: function() {
            return !0;
          },
          registerDocumentInteractionHandler: function() {
          },
          registerInteractionHandler: function() {
          },
          registerResizeHandler: function() {
          },
          removeClass: function() {
          },
          updateCssVariable: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.init = function() {
      var e = this, i = this.supportsPressRipple();
      if (this.registerRootHandlers(i), i) {
        var r = t.cssClasses, n = r.ROOT, o = r.UNBOUNDED;
        requestAnimationFrame(function() {
          e.adapter.addClass(n), e.adapter.isUnbounded() && (e.adapter.addClass(o), e.layoutInternal());
        });
      }
    }, t.prototype.destroy = function() {
      var e = this;
      if (this.supportsPressRipple()) {
        this.activationTimer && (clearTimeout(this.activationTimer), this.activationTimer = 0, this.adapter.removeClass(t.cssClasses.FG_ACTIVATION)), this.fgDeactivationRemovalTimer && (clearTimeout(this.fgDeactivationRemovalTimer), this.fgDeactivationRemovalTimer = 0, this.adapter.removeClass(t.cssClasses.FG_DEACTIVATION));
        var i = t.cssClasses, r = i.ROOT, n = i.UNBOUNDED;
        requestAnimationFrame(function() {
          e.adapter.removeClass(r), e.adapter.removeClass(n), e.removeCssVars();
        });
      }
      this.deregisterRootHandlers(), this.deregisterDeactivationHandlers();
    }, t.prototype.activate = function(e) {
      this.activateImpl(e);
    }, t.prototype.deactivate = function() {
      this.deactivateImpl();
    }, t.prototype.layout = function() {
      var e = this;
      this.layoutFrame && cancelAnimationFrame(this.layoutFrame), this.layoutFrame = requestAnimationFrame(function() {
        e.layoutInternal(), e.layoutFrame = 0;
      });
    }, t.prototype.setUnbounded = function(e) {
      var i = t.cssClasses.UNBOUNDED;
      e ? this.adapter.addClass(i) : this.adapter.removeClass(i);
    }, t.prototype.handleFocus = function() {
      var e = this;
      requestAnimationFrame(function() {
        return e.adapter.addClass(t.cssClasses.BG_FOCUSED);
      });
    }, t.prototype.handleBlur = function() {
      var e = this;
      requestAnimationFrame(function() {
        return e.adapter.removeClass(t.cssClasses.BG_FOCUSED);
      });
    }, t.prototype.supportsPressRipple = function() {
      return this.adapter.browserSupportsCssVars();
    }, t.prototype.defaultActivationState = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: !1,
        isActivated: !1,
        isProgrammatic: !1,
        wasActivatedByPointer: !1,
        wasElementMadeActive: !1
      };
    }, t.prototype.registerRootHandlers = function(e) {
      var i, r;
      if (e) {
        try {
          for (var n = Pe(nn), o = n.next(); !o.done; o = n.next()) {
            var c = o.value;
            this.adapter.registerInteractionHandler(c, this.activateHandler);
          }
        } catch (a) {
          i = { error: a };
        } finally {
          try {
            o && !o.done && (r = n.return) && r.call(n);
          } finally {
            if (i) throw i.error;
          }
        }
        this.adapter.isUnbounded() && this.adapter.registerResizeHandler(this.resizeHandler);
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler), this.adapter.registerInteractionHandler("blur", this.blurHandler);
    }, t.prototype.registerDeactivationHandlers = function(e) {
      var i, r;
      if (e.type === "keydown")
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
      else
        try {
          for (var n = Pe(on), o = n.next(); !o.done; o = n.next()) {
            var c = o.value;
            this.adapter.registerDocumentInteractionHandler(c, this.deactivateHandler);
          }
        } catch (a) {
          i = { error: a };
        } finally {
          try {
            o && !o.done && (r = n.return) && r.call(n);
          } finally {
            if (i) throw i.error;
          }
        }
    }, t.prototype.deregisterRootHandlers = function() {
      var e, i;
      try {
        for (var r = Pe(nn), n = r.next(); !n.done; n = r.next()) {
          var o = n.value;
          this.adapter.deregisterInteractionHandler(o, this.activateHandler);
        }
      } catch (c) {
        e = { error: c };
      } finally {
        try {
          n && !n.done && (i = r.return) && i.call(r);
        } finally {
          if (e) throw e.error;
        }
      }
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler), this.adapter.deregisterInteractionHandler("blur", this.blurHandler), this.adapter.isUnbounded() && this.adapter.deregisterResizeHandler(this.resizeHandler);
    }, t.prototype.deregisterDeactivationHandlers = function() {
      var e, i;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
      try {
        for (var r = Pe(on), n = r.next(); !n.done; n = r.next()) {
          var o = n.value;
          this.adapter.deregisterDocumentInteractionHandler(o, this.deactivateHandler);
        }
      } catch (c) {
        e = { error: c };
      } finally {
        try {
          n && !n.done && (i = r.return) && i.call(r);
        } finally {
          if (e) throw e.error;
        }
      }
    }, t.prototype.removeCssVars = function() {
      var e = this, i = t.strings, r = Object.keys(i);
      r.forEach(function(n) {
        n.indexOf("VAR_") === 0 && e.adapter.updateCssVariable(i[n], null);
      });
    }, t.prototype.activateImpl = function(e) {
      var i = this;
      if (!this.adapter.isSurfaceDisabled()) {
        var r = this.activationState;
        if (!r.isActivated) {
          var n = this.previousActivationEvent, o = n && e !== void 0 && n.type !== e.type;
          if (!o) {
            r.isActivated = !0, r.isProgrammatic = e === void 0, r.activationEvent = e, r.wasActivatedByPointer = r.isProgrammatic ? !1 : e !== void 0 && (e.type === "mousedown" || e.type === "touchstart" || e.type === "pointerdown");
            var c = e !== void 0 && Oe.length > 0 && Oe.some(function(a) {
              return i.adapter.containsEventTarget(a);
            });
            if (c) {
              this.resetActivationState();
              return;
            }
            e !== void 0 && (Oe.push(e.target), this.registerDeactivationHandlers(e)), r.wasElementMadeActive = this.checkElementMadeActive(e), r.wasElementMadeActive && this.animateActivation(), requestAnimationFrame(function() {
              Oe = [], !r.wasElementMadeActive && e !== void 0 && (e.key === " " || e.keyCode === 32) && (r.wasElementMadeActive = i.checkElementMadeActive(e), r.wasElementMadeActive && i.animateActivation()), r.wasElementMadeActive || (i.activationState = i.defaultActivationState());
            });
          }
        }
      }
    }, t.prototype.checkElementMadeActive = function(e) {
      return e !== void 0 && e.type === "keydown" ? this.adapter.isSurfaceActive() : !0;
    }, t.prototype.animateActivation = function() {
      var e = this, i = t.strings, r = i.VAR_FG_TRANSLATE_START, n = i.VAR_FG_TRANSLATE_END, o = t.cssClasses, c = o.FG_DEACTIVATION, a = o.FG_ACTIVATION, l = t.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal();
      var h = "", d = "";
      if (!this.adapter.isUnbounded()) {
        var p = this.getFgTranslationCoordinates(), u = p.startPoint, v = p.endPoint;
        h = u.x + "px, " + u.y + "px", d = v.x + "px, " + v.y + "px";
      }
      this.adapter.updateCssVariable(r, h), this.adapter.updateCssVariable(n, d), clearTimeout(this.activationTimer), clearTimeout(this.fgDeactivationRemovalTimer), this.rmBoundedActivationClasses(), this.adapter.removeClass(c), this.adapter.computeBoundingRect(), this.adapter.addClass(a), this.activationTimer = setTimeout(function() {
        e.activationTimerCallback();
      }, l);
    }, t.prototype.getFgTranslationCoordinates = function() {
      var e = this.activationState, i = e.activationEvent, r = e.wasActivatedByPointer, n;
      r ? n = ec(i, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect()) : n = {
        x: this.frame.width / 2,
        y: this.frame.height / 2
      }, n = {
        x: n.x - this.initialSize / 2,
        y: n.y - this.initialSize / 2
      };
      var o = {
        x: this.frame.width / 2 - this.initialSize / 2,
        y: this.frame.height / 2 - this.initialSize / 2
      };
      return { startPoint: n, endPoint: o };
    }, t.prototype.runDeactivationUXLogicIfReady = function() {
      var e = this, i = t.cssClasses.FG_DEACTIVATION, r = this.activationState, n = r.hasDeactivationUXRun, o = r.isActivated, c = n || !o;
      c && this.activationAnimationHasEnded && (this.rmBoundedActivationClasses(), this.adapter.addClass(i), this.fgDeactivationRemovalTimer = setTimeout(function() {
        e.adapter.removeClass(i);
      }, sn.FG_DEACTIVATION_MS));
    }, t.prototype.rmBoundedActivationClasses = function() {
      var e = t.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(e), this.activationAnimationHasEnded = !1, this.adapter.computeBoundingRect();
    }, t.prototype.resetActivationState = function() {
      var e = this;
      this.previousActivationEvent = this.activationState.activationEvent, this.activationState = this.defaultActivationState(), setTimeout(function() {
        return e.previousActivationEvent = void 0;
      }, t.numbers.TAP_DELAY_MS);
    }, t.prototype.deactivateImpl = function() {
      var e = this, i = this.activationState;
      if (i.isActivated) {
        var r = R({}, i);
        i.isProgrammatic ? (requestAnimationFrame(function() {
          e.animateDeactivation(r);
        }), this.resetActivationState()) : (this.deregisterDeactivationHandlers(), requestAnimationFrame(function() {
          e.activationState.hasDeactivationUXRun = !0, e.animateDeactivation(r), e.resetActivationState();
        }));
      }
    }, t.prototype.animateDeactivation = function(e) {
      var i = e.wasActivatedByPointer, r = e.wasElementMadeActive;
      (i || r) && this.runDeactivationUXLogicIfReady();
    }, t.prototype.layoutInternal = function() {
      var e = this;
      this.frame = this.adapter.computeBoundingRect();
      var i = Math.max(this.frame.height, this.frame.width), r = function() {
        var o = Math.sqrt(Math.pow(e.frame.width, 2) + Math.pow(e.frame.height, 2));
        return o + t.numbers.PADDING;
      };
      this.maxRadius = this.adapter.isUnbounded() ? i : r();
      var n = Math.floor(i * t.numbers.INITIAL_ORIGIN_SCALE);
      this.adapter.isUnbounded() && n % 2 !== 0 ? this.initialSize = n - 1 : this.initialSize = n, this.fgScale = "" + this.maxRadius / this.initialSize, this.updateLayoutCssVars();
    }, t.prototype.updateLayoutCssVars = function() {
      var e = t.strings, i = e.VAR_FG_SIZE, r = e.VAR_LEFT, n = e.VAR_TOP, o = e.VAR_FG_SCALE;
      this.adapter.updateCssVariable(i, this.initialSize + "px"), this.adapter.updateCssVariable(o, this.fgScale), this.adapter.isUnbounded() && (this.unboundedCoords = {
        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
      }, this.adapter.updateCssVariable(r, this.unboundedCoords.left + "px"), this.adapter.updateCssVariable(n, this.unboundedCoords.top + "px"));
    }, t;
  }(Ae)
);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Me = window, is = Me.ShadowRoot && (Me.ShadyCSS === void 0 || Me.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, rs = Symbol(), an = /* @__PURE__ */ new WeakMap();
let Do = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== rs) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (is && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = an.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && an.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const rc = (s) => new Do(typeof s == "string" ? s : s + "", void 0, rs), sc = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new Do(e, s, rs);
}, nc = (s, t) => {
  is ? s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach((e) => {
    const i = document.createElement("style"), r = Me.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  });
}, ln = is ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return rc(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Ii;
const Ze = window, cn = Ze.trustedTypes, oc = cn ? cn.emptyScript : "", dn = Ze.reactiveElementPolyfillSupport, Ar = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? oc : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, zo = (s, t) => t !== s && (t == t || s == s), Mi = { attribute: !0, type: String, converter: Ar, reflect: !1, hasChanged: zo }, Sr = "finalized";
let St = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(t) {
    var e;
    this.finalize(), ((e = this.h) !== null && e !== void 0 ? e : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((e, i) => {
      const r = this._$Ep(i, e);
      r !== void 0 && (this._$Ev.set(r, i), t.push(r));
    }), t;
  }
  static createProperty(t, e = Mi) {
    if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const i = typeof t == "symbol" ? Symbol() : "__" + t, r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && Object.defineProperty(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return { get() {
      return this[e];
    }, set(r) {
      const n = this[t];
      this[e] = r, this.requestUpdate(t, n, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || Mi;
  }
  static finalize() {
    if (this.hasOwnProperty(Sr)) return !1;
    this[Sr] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e = this.properties, i = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(ln(r));
    } else t !== void 0 && e.push(ln(t));
    return e;
  }
  static _$Ep(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  _$Eu() {
    var t;
    this._$E_ = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((e) => e(this));
  }
  addController(t) {
    var e, i;
    ((e = this._$ES) !== null && e !== void 0 ? e : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) === null || i === void 0 || i.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return nc(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EO(t, e, i = Mi) {
    var r;
    const n = this.constructor._$Ep(t, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) === null || r === void 0 ? void 0 : r.toAttribute) !== void 0 ? i.converter : Ar).toAttribute(e, i.type);
      this._$El = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null;
    }
  }
  _$AK(t, e) {
    var i;
    const r = this.constructor, n = r._$Ev.get(t);
    if (n !== void 0 && this._$El !== n) {
      const o = r.getPropertyOptions(n), c = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? o.converter : Ar;
      this._$El = n, this[n] = c.fromAttribute(e, o.type), this._$El = null;
    }
  }
  requestUpdate(t, e, i) {
    let r = !0;
    t !== void 0 && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || zo)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, i))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((r, n) => this[n] = r), this._$Ei = void 0);
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
        var n;
        return (n = r.hostUpdate) === null || n === void 0 ? void 0 : n.call(r);
      }), this.update(i)) : this._$Ek();
    } catch (r) {
      throw e = !1, this._$Ek(), r;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) === null || r === void 0 ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((e, i) => this._$EO(i, this[i], e)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
St[Sr] = !0, St.elementProperties = /* @__PURE__ */ new Map(), St.elementStyles = [], St.shadowRootOptions = { mode: "open" }, dn == null || dn({ ReactiveElement: St }), ((Ii = Ze.reactiveElementVersions) !== null && Ii !== void 0 ? Ii : Ze.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Ni;
const Ye = window, Mt = Ye.trustedTypes, hn = Mt ? Mt.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Er = "$lit$", D = `lit$${(Math.random() + "").slice(9)}$`, Bo = "?" + D, ac = `<${Bo}>`, ut = document, pe = () => ut.createComment(""), ue = (s) => s === null || typeof s != "object" && typeof s != "function", jo = Array.isArray, lc = (s) => jo(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", Di = `[ 	
\f\r]`, Jt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, pn = /-->/g, un = />/g, X = RegExp(`>|${Di}(?:([^\\s"'>=/]+)(${Di}*=${Di}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), fn = /'/g, mn = /"/g, Fo = /^(?:script|style|textarea|title)$/i, cc = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), dc = cc(1), V = Symbol.for("lit-noChange"), E = Symbol.for("lit-nothing"), vn = /* @__PURE__ */ new WeakMap(), rt = ut.createTreeWalker(ut, 129, null, !1);
function Vo(s, t) {
  if (!Array.isArray(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return hn !== void 0 ? hn.createHTML(t) : t;
}
const hc = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : "", o = Jt;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === Jt ? h[1] === "!--" ? o = pn : h[1] !== void 0 ? o = un : h[2] !== void 0 ? (Fo.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = X) : h[3] !== void 0 && (o = X) : o === X ? h[0] === ">" ? (o = r ?? Jt, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? X : h[3] === '"' ? mn : fn) : o === mn || o === fn ? o = X : o === pn || o === un ? o = Jt : (o = X, r = void 0);
    const u = o === X && s[c + 1].startsWith("/>") ? " " : "";
    n += o === Jt ? a + ac : d >= 0 ? (i.push(l), a.slice(0, d) + Er + a.slice(d) + D + u) : a + D + (d === -2 ? (i.push(void 0), c) : u);
  }
  return [Vo(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : "")), i];
};
let Cr = class Wo {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = hc(t, e);
    if (this.el = Wo.createElement(l, i), rt.currentNode = this.el.content, e === 2) {
      const d = this.el.content, p = d.firstChild;
      p.remove(), d.append(...p.childNodes);
    }
    for (; (r = rt.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) {
          const d = [];
          for (const p of r.getAttributeNames()) if (p.endsWith(Er) || p.startsWith(D)) {
            const u = h[o++];
            if (d.push(p), u !== void 0) {
              const v = r.getAttribute(u.toLowerCase() + Er).split(D), m = /([.?@])?(.*)/.exec(u);
              a.push({ type: 1, index: n, name: m[2], strings: v, ctor: m[1] === "." ? uc : m[1] === "?" ? mc : m[1] === "@" ? vc : li });
            } else a.push({ type: 6, index: n });
          }
          for (const p of d) r.removeAttribute(p);
        }
        if (Fo.test(r.tagName)) {
          const d = r.textContent.split(D), p = d.length - 1;
          if (p > 0) {
            r.textContent = Mt ? Mt.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], pe()), rt.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], pe());
          }
        }
      } else if (r.nodeType === 8) if (r.data === Bo) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(D, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += D.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = ut.createElement("template");
    return i.innerHTML = t, i;
  }
};
function Nt(s, t, e = s, i) {
  var r, n, o, c;
  if (t === V) return t;
  let a = i !== void 0 ? (r = e._$Co) === null || r === void 0 ? void 0 : r[i] : e._$Cl;
  const l = ue(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== l && ((n = a == null ? void 0 : a._$AO) === null || n === void 0 || n.call(a, !1), l === void 0 ? a = void 0 : (a = new l(s), a._$AT(s, e, i)), i !== void 0 ? ((o = (c = e)._$Co) !== null && o !== void 0 ? o : c._$Co = [])[i] = a : e._$Cl = a), a !== void 0 && (t = Nt(s, a._$AS(s, t.values), a, i)), t;
}
let pc = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var e;
    const { el: { content: i }, parts: r } = this._$AD, n = ((e = t == null ? void 0 : t.creationScope) !== null && e !== void 0 ? e : ut).importNode(i, !0);
    rt.currentNode = n;
    let o = rt.nextNode(), c = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (c === l.index) {
        let h;
        l.type === 2 ? h = new ss(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new gc(o, this, t)), this._$AV.push(h), l = r[++a];
      }
      c !== (l == null ? void 0 : l.index) && (o = rt.nextNode(), c++);
    }
    return rt.currentNode = ut, n;
  }
  v(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, ss = class Ko {
  constructor(t, e, i, r) {
    var n;
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cp = (n = r == null ? void 0 : r.isConnected) === null || n === void 0 || n;
  }
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && e !== void 0 ? e : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Nt(this, t, e), ue(t) ? t === E || t == null || t === "" ? (this._$AH !== E && this._$AR(), this._$AH = E) : t !== this._$AH && t !== V && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : lc(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== E && ue(this._$AH) ? this._$AA.nextSibling.data = t : this.$(ut.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var e;
    const { values: i, _$litType$: r } = t, n = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = Cr.createElement(Vo(r.h, r.h[0]), this.options)), r);
    if (((e = this._$AH) === null || e === void 0 ? void 0 : e._$AD) === n) this._$AH.v(i);
    else {
      const o = new pc(n, this), c = o.u(this.options);
      o.v(i), this.$(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = vn.get(t.strings);
    return e === void 0 && vn.set(t.strings, e = new Cr(t)), e;
  }
  T(t) {
    jo(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new Ko(this.k(pe()), this.k(pe()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cp = t, (e = this._$AP) === null || e === void 0 || e.call(this, t));
  }
}, li = class {
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = E;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = Nt(this, t, e, 0), o = !ue(t) || t !== this._$AH && t !== V, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = Nt(this, c[i + a], e, a), l === V && (l = this._$AH[a]), o || (o = !ue(l) || l !== this._$AH[a]), l === E ? t = E : t !== E && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, uc = class extends li {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === E ? void 0 : t;
  }
};
const fc = Mt ? Mt.emptyScript : "";
let mc = class extends li {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== E ? this.element.setAttribute(this.name, fc) : this.element.removeAttribute(this.name);
  }
}, vc = class extends li {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    var i;
    if ((t = (i = Nt(this, t, e, 0)) !== null && i !== void 0 ? i : E) === V) return;
    const r = this._$AH, n = t === E && r !== E || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== E && (r === E || n);
    n && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, i;
    typeof this._$AH == "function" ? this._$AH.call((i = (e = this.options) === null || e === void 0 ? void 0 : e.host) !== null && i !== void 0 ? i : this.element, t) : this._$AH.handleEvent(t);
  }
}, gc = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Nt(this, t);
  }
};
const gn = Ye.litHtmlPolyfillSupport;
gn == null || gn(Cr, ss), ((Ni = Ye.litHtmlVersions) !== null && Ni !== void 0 ? Ni : Ye.litHtmlVersions = []).push("2.8.0");
const $c = (s, t, e) => {
  var i, r;
  const n = (i = e == null ? void 0 : e.renderBefore) !== null && i !== void 0 ? i : t;
  let o = n._$litPart$;
  if (o === void 0) {
    const c = (r = e == null ? void 0 : e.renderBefore) !== null && r !== void 0 ? r : null;
    n._$litPart$ = o = new ss(t.insertBefore(pe(), c), c, void 0, e ?? {});
  }
  return o._$AI(s), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var zi, Bi;
let Ne = class extends St {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (t = (e = this.renderOptions).renderBefore) !== null && t !== void 0 || (e.renderBefore = i.firstChild), i;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = $c(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return V;
  }
};
Ne.finalized = !0, Ne._$litElement$ = !0, (zi = globalThis.litElementHydrateSupport) === null || zi === void 0 || zi.call(globalThis, { LitElement: Ne });
const $n = globalThis.litElementPolyfillSupport;
$n == null || $n({ LitElement: Ne });
((Bi = globalThis.litElementVersions) !== null && Bi !== void 0 ? Bi : globalThis.litElementVersions = []).push("3.3.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Go = { ATTRIBUTE: 1 }, qo = (s) => (...t) => ({ _$litDirective$: s, values: t });
let Xo = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _c = qo(class extends Xo {
  constructor(s) {
    var t;
    if (super(s), s.type !== Go.ATTRIBUTE || s.name !== "class" || ((t = s.strings) === null || t === void 0 ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return " " + Object.keys(s).filter((t) => s[t]).join(" ") + " ";
  }
  update(s, [t]) {
    var e, i;
    if (this.it === void 0) {
      this.it = /* @__PURE__ */ new Set(), s.strings !== void 0 && (this.nt = new Set(s.strings.join(" ").split(/\s/).filter((n) => n !== "")));
      for (const n in t) t[n] && !(!((e = this.nt) === null || e === void 0) && e.has(n)) && this.it.add(n);
      return this.render(t);
    }
    const r = s.element.classList;
    this.it.forEach((n) => {
      n in t || (r.remove(n), this.it.delete(n));
    });
    for (const n in t) {
      const o = !!t[n];
      o === this.it.has(n) || !((i = this.nt) === null || i === void 0) && i.has(n) || (o ? (r.add(n), this.it.add(n)) : (r.remove(n), this.it.delete(n)));
    }
    return V;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Zo = "important", yc = " !" + Zo, bc = qo(class extends Xo {
  constructor(s) {
    var t;
    if (super(s), s.type !== Go.ATTRIBUTE || s.name !== "style" || ((t = s.strings) === null || t === void 0 ? void 0 : t.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return Object.keys(s).reduce((t, e) => {
      const i = s[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }, "");
  }
  update(s, [t]) {
    const { style: e } = s.element;
    if (this.ht === void 0) {
      this.ht = /* @__PURE__ */ new Set();
      for (const i in t) this.ht.add(i);
      return this.render(t);
    }
    this.ht.forEach((i) => {
      t[i] == null && (this.ht.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = "");
    });
    for (const i in t) {
      const r = t[i];
      if (r != null) {
        this.ht.add(i);
        const n = typeof r == "string" && r.endsWith(yc);
        i.includes("-") || n ? e.setProperty(i, n ? r.slice(0, -11) : r, n ? Zo : "") : e[i] = r;
      }
    }
    return V;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class y extends be {
  constructor() {
    super(...arguments), this.primary = !1, this.accent = !1, this.unbounded = !1, this.disabled = !1, this.activated = !1, this.selected = !1, this.internalUseStateLayerCustomProperties = !1, this.hovering = !1, this.bgFocused = !1, this.fgActivation = !1, this.fgDeactivation = !1, this.fgScale = "", this.fgSize = "", this.translateStart = "", this.translateEnd = "", this.leftPos = "", this.topPos = "", this.mdcFoundationClass = ic;
  }
  get isActive() {
    return No(this.parentElement || this, ":active");
  }
  createAdapter() {
    return {
      browserSupportsCssVars: () => !0,
      isUnbounded: () => this.unbounded,
      isSurfaceActive: () => this.isActive,
      isSurfaceDisabled: () => this.disabled,
      addClass: (t) => {
        switch (t) {
          case "mdc-ripple-upgraded--background-focused":
            this.bgFocused = !0;
            break;
          case "mdc-ripple-upgraded--foreground-activation":
            this.fgActivation = !0;
            break;
          case "mdc-ripple-upgraded--foreground-deactivation":
            this.fgDeactivation = !0;
            break;
        }
      },
      removeClass: (t) => {
        switch (t) {
          case "mdc-ripple-upgraded--background-focused":
            this.bgFocused = !1;
            break;
          case "mdc-ripple-upgraded--foreground-activation":
            this.fgActivation = !1;
            break;
          case "mdc-ripple-upgraded--foreground-deactivation":
            this.fgDeactivation = !1;
            break;
        }
      },
      containsEventTarget: () => !0,
      registerInteractionHandler: () => {
      },
      deregisterInteractionHandler: () => {
      },
      registerDocumentInteractionHandler: () => {
      },
      deregisterDocumentInteractionHandler: () => {
      },
      registerResizeHandler: () => {
      },
      deregisterResizeHandler: () => {
      },
      updateCssVariable: (t, e) => {
        switch (t) {
          case "--mdc-ripple-fg-scale":
            this.fgScale = e;
            break;
          case "--mdc-ripple-fg-size":
            this.fgSize = e;
            break;
          case "--mdc-ripple-fg-translate-end":
            this.translateEnd = e;
            break;
          case "--mdc-ripple-fg-translate-start":
            this.translateStart = e;
            break;
          case "--mdc-ripple-left":
            this.leftPos = e;
            break;
          case "--mdc-ripple-top":
            this.topPos = e;
            break;
        }
      },
      computeBoundingRect: () => (this.parentElement || this).getBoundingClientRect(),
      getWindowPageOffset: () => ({ x: window.pageXOffset, y: window.pageYOffset })
    };
  }
  startPress(t) {
    this.waitForFoundation(() => {
      this.mdcFoundation.activate(t);
    });
  }
  endPress() {
    this.waitForFoundation(() => {
      this.mdcFoundation.deactivate();
    });
  }
  startFocus() {
    this.waitForFoundation(() => {
      this.mdcFoundation.handleFocus();
    });
  }
  endFocus() {
    this.waitForFoundation(() => {
      this.mdcFoundation.handleBlur();
    });
  }
  startHover() {
    this.hovering = !0;
  }
  endHover() {
    this.hovering = !1;
  }
  /**
   * Wait for the MDCFoundation to be created by `firstUpdated`
   */
  waitForFoundation(t) {
    this.mdcFoundation ? t() : this.updateComplete.then(t);
  }
  update(t) {
    t.has("disabled") && this.disabled && this.endHover(), super.update(t);
  }
  /** @soyTemplate */
  render() {
    const t = this.activated && (this.primary || !this.accent), e = this.selected && (this.primary || !this.accent), i = {
      "mdc-ripple-surface--accent": this.accent,
      "mdc-ripple-surface--primary--activated": t,
      "mdc-ripple-surface--accent--activated": this.accent && this.activated,
      "mdc-ripple-surface--primary--selected": e,
      "mdc-ripple-surface--accent--selected": this.accent && this.selected,
      "mdc-ripple-surface--disabled": this.disabled,
      "mdc-ripple-surface--hover": this.hovering,
      "mdc-ripple-surface--primary": this.primary,
      "mdc-ripple-surface--selected": this.selected,
      "mdc-ripple-upgraded--background-focused": this.bgFocused,
      "mdc-ripple-upgraded--foreground-activation": this.fgActivation,
      "mdc-ripple-upgraded--foreground-deactivation": this.fgDeactivation,
      "mdc-ripple-upgraded--unbounded": this.unbounded,
      "mdc-ripple-surface--internal-use-state-layer-custom-properties": this.internalUseStateLayerCustomProperties
    };
    return dc`
        <div class="mdc-ripple-surface mdc-ripple-upgraded ${_c(i)}"
          style="${bc({
      "--mdc-ripple-fg-scale": this.fgScale,
      "--mdc-ripple-fg-size": this.fgSize,
      "--mdc-ripple-fg-translate-end": this.translateEnd,
      "--mdc-ripple-fg-translate-start": this.translateStart,
      "--mdc-ripple-left": this.leftPos,
      "--mdc-ripple-top": this.topPos
    })}"></div>`;
  }
}
f([
  Jl(".mdc-ripple-surface")
], y.prototype, "mdcRoot", void 0);
f([
  W({ type: Boolean })
], y.prototype, "primary", void 0);
f([
  W({ type: Boolean })
], y.prototype, "accent", void 0);
f([
  W({ type: Boolean })
], y.prototype, "unbounded", void 0);
f([
  W({ type: Boolean })
], y.prototype, "disabled", void 0);
f([
  W({ type: Boolean })
], y.prototype, "activated", void 0);
f([
  W({ type: Boolean })
], y.prototype, "selected", void 0);
f([
  W({ type: Boolean })
], y.prototype, "internalUseStateLayerCustomProperties", void 0);
f([
  U()
], y.prototype, "hovering", void 0);
f([
  U()
], y.prototype, "bgFocused", void 0);
f([
  U()
], y.prototype, "fgActivation", void 0);
f([
  U()
], y.prototype, "fgDeactivation", void 0);
f([
  U()
], y.prototype, "fgScale", void 0);
f([
  U()
], y.prototype, "fgSize", void 0);
f([
  U()
], y.prototype, "translateStart", void 0);
f([
  U()
], y.prototype, "translateEnd", void 0);
f([
  U()
], y.prototype, "leftPos", void 0);
f([
  U()
], y.prototype, "topPos", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const Ac = sc`.mdc-ripple-surface{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity;position:relative;outline:none;overflow:hidden}.mdc-ripple-surface::before,.mdc-ripple-surface::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-ripple-surface::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index, 1)}.mdc-ripple-surface::after{z-index:0;z-index:var(--mdc-ripple-z-index, 0)}.mdc-ripple-surface.mdc-ripple-upgraded::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-ripple-surface.mdc-ripple-upgraded::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-ripple-surface::before,.mdc-ripple-surface::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-ripple-surface.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded],.mdc-ripple-upgraded--unbounded{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]::before,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]::after,.mdc-ripple-upgraded--unbounded::before,.mdc-ripple-upgraded--unbounded::after{top:calc(50% - 50%);left:calc(50% - 50%);width:100%;height:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::before,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::before,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::after{top:var(--mdc-ripple-top, calc(50% - 50%));left:var(--mdc-ripple-left, calc(50% - 50%));width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface::before,.mdc-ripple-surface::after{background-color:#000;background-color:var(--mdc-ripple-color, #000)}.mdc-ripple-surface:hover::before,.mdc-ripple-surface.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}:host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:block}:host .mdc-ripple-surface{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;will-change:unset}.mdc-ripple-surface--primary::before,.mdc-ripple-surface--primary::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary:hover::before,.mdc-ripple-surface--primary.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface--primary.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--primary--activated::before{opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12)}.mdc-ripple-surface--primary--activated::before,.mdc-ripple-surface--primary--activated::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary--activated:hover::before,.mdc-ripple-surface--primary--activated.mdc-ripple-surface--hover::before{opacity:0.16;opacity:var(--mdc-ripple-hover-opacity, 0.16)}.mdc-ripple-surface--primary--activated.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--primary--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--primary--selected::before{opacity:0.08;opacity:var(--mdc-ripple-selected-opacity, 0.08)}.mdc-ripple-surface--primary--selected::before,.mdc-ripple-surface--primary--selected::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary--selected:hover::before,.mdc-ripple-surface--primary--selected.mdc-ripple-surface--hover::before{opacity:0.12;opacity:var(--mdc-ripple-hover-opacity, 0.12)}.mdc-ripple-surface--primary--selected.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-focus-opacity, 0.2)}.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--primary--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--accent::before,.mdc-ripple-surface--accent::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent:hover::before,.mdc-ripple-surface--accent.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface--accent.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--accent.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--accent--activated::before{opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12)}.mdc-ripple-surface--accent--activated::before,.mdc-ripple-surface--accent--activated::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent--activated:hover::before,.mdc-ripple-surface--accent--activated.mdc-ripple-surface--hover::before{opacity:0.16;opacity:var(--mdc-ripple-hover-opacity, 0.16)}.mdc-ripple-surface--accent--activated.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--accent--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--accent--selected::before{opacity:0.08;opacity:var(--mdc-ripple-selected-opacity, 0.08)}.mdc-ripple-surface--accent--selected::before,.mdc-ripple-surface--accent--selected::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent--selected:hover::before,.mdc-ripple-surface--accent--selected.mdc-ripple-surface--hover::before{opacity:0.12;opacity:var(--mdc-ripple-hover-opacity, 0.12)}.mdc-ripple-surface--accent--selected.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-focus-opacity, 0.2)}.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--accent--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--disabled{opacity:0}.mdc-ripple-surface--internal-use-state-layer-custom-properties::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties::after{background-color:#000;background-color:var(--mdc-ripple-hover-state-layer-color, #000)}.mdc-ripple-surface--internal-use-state-layer-custom-properties:hover::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-state-layer-opacity, 0.04)}.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-state-layer-opacity, 0.12)}.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-pressed-state-layer-opacity, 0.12)}.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-pressed-state-layer-opacity, 0.12)}`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let wr = class extends y {
};
wr.styles = [Ac];
wr = f([
  ql("mwc-ripple")
], wr);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Yo = (s) => (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (t, e) => {
    if (t.constructor._observers) {
      if (!t.constructor.hasOwnProperty("_observers")) {
        const i = t.constructor._observers;
        t.constructor._observers = /* @__PURE__ */ new Map(), i.forEach(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (r, n) => t.constructor._observers.set(n, r)
        );
      }
    } else {
      t.constructor._observers = /* @__PURE__ */ new Map();
      const i = t.updated;
      t.updated = function(r) {
        i.call(this, r), r.forEach((n, o) => {
          const a = this.constructor._observers.get(o);
          a !== void 0 && a.call(this, this[o], n);
        });
      };
    }
    t.constructor._observers.set(e, s);
  }
);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Sc {
  constructor(t) {
    this.startPress = (e) => {
      t().then((i) => {
        i && i.startPress(e);
      });
    }, this.endPress = () => {
      t().then((e) => {
        e && e.endPress();
      });
    }, this.startFocus = () => {
      t().then((e) => {
        e && e.startFocus();
      });
    }, this.endFocus = () => {
      t().then((e) => {
        e && e.endFocus();
      });
    }, this.startHover = () => {
      t().then((e) => {
        e && e.startHover();
      });
    }, this.endHover = () => {
      t().then((e) => {
        e && e.endHover();
      });
    };
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ke = {
  ACTIVE: "mdc-tab--active"
}, Qt = {
  ARIA_SELECTED: "aria-selected",
  CONTENT_SELECTOR: ".mdc-tab__content",
  INTERACTED_EVENT: "MDCTab:interacted",
  RIPPLE_SELECTOR: ".mdc-tab__ripple",
  TABINDEX: "tabIndex",
  TAB_INDICATOR_SELECTOR: ".mdc-tab-indicator"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _n = (
  /** @class */
  function(s) {
    H(t, s);
    function t(e) {
      var i = s.call(this, R(R({}, t.defaultAdapter), e)) || this;
      return i.focusOnActivate = !0, i;
    }
    return Object.defineProperty(t, "cssClasses", {
      get: function() {
        return ke;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "strings", {
      get: function() {
        return Qt;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          hasClass: function() {
            return !1;
          },
          setAttr: function() {
          },
          activateIndicator: function() {
          },
          deactivateIndicator: function() {
          },
          notifyInteracted: function() {
          },
          getOffsetLeft: function() {
            return 0;
          },
          getOffsetWidth: function() {
            return 0;
          },
          getContentOffsetLeft: function() {
            return 0;
          },
          getContentOffsetWidth: function() {
            return 0;
          },
          focus: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.handleClick = function() {
      this.adapter.notifyInteracted();
    }, t.prototype.isActive = function() {
      return this.adapter.hasClass(ke.ACTIVE);
    }, t.prototype.setFocusOnActivate = function(e) {
      this.focusOnActivate = e;
    }, t.prototype.activate = function(e) {
      this.adapter.addClass(ke.ACTIVE), this.adapter.setAttr(Qt.ARIA_SELECTED, "true"), this.adapter.setAttr(Qt.TABINDEX, "0"), this.adapter.activateIndicator(e), this.focusOnActivate && this.adapter.focus();
    }, t.prototype.deactivate = function() {
      this.isActive() && (this.adapter.removeClass(ke.ACTIVE), this.adapter.setAttr(Qt.ARIA_SELECTED, "false"), this.adapter.setAttr(Qt.TABINDEX, "-1"), this.adapter.deactivateIndicator());
    }, t.prototype.computeDimensions = function() {
      var e = this.adapter.getOffsetWidth(), i = this.adapter.getOffsetLeft(), r = this.adapter.getContentOffsetWidth(), n = this.adapter.getContentOffsetLeft();
      return {
        contentLeft: i + n,
        contentRight: i + n + r,
        rootLeft: i,
        rootRight: i + e
      };
    }, t;
  }(Ae)
);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const De = window, ns = De.ShadowRoot && (De.ShadyCSS === void 0 || De.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, os = Symbol(), yn = /* @__PURE__ */ new WeakMap();
let Jo = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== os) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (ns && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = yn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && yn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Ec = (s) => new Jo(typeof s == "string" ? s : s + "", void 0, os), Cc = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new Jo(e, s, os);
}, wc = (s, t) => {
  ns ? s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach((e) => {
    const i = document.createElement("style"), r = De.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  });
}, bn = ns ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return Ec(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var ji;
const Je = window, An = Je.trustedTypes, xc = An ? An.emptyScript : "", Sn = Je.reactiveElementPolyfillSupport, xr = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? xc : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, Qo = (s, t) => t !== s && (t == t || s == s), Fi = { attribute: !0, type: String, converter: xr, reflect: !1, hasChanged: Qo }, Tr = "finalized";
let Et = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(t) {
    var e;
    this.finalize(), ((e = this.h) !== null && e !== void 0 ? e : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((e, i) => {
      const r = this._$Ep(i, e);
      r !== void 0 && (this._$Ev.set(r, i), t.push(r));
    }), t;
  }
  static createProperty(t, e = Fi) {
    if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const i = typeof t == "symbol" ? Symbol() : "__" + t, r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && Object.defineProperty(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return { get() {
      return this[e];
    }, set(r) {
      const n = this[t];
      this[e] = r, this.requestUpdate(t, n, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || Fi;
  }
  static finalize() {
    if (this.hasOwnProperty(Tr)) return !1;
    this[Tr] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e = this.properties, i = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(bn(r));
    } else t !== void 0 && e.push(bn(t));
    return e;
  }
  static _$Ep(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  _$Eu() {
    var t;
    this._$E_ = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((e) => e(this));
  }
  addController(t) {
    var e, i;
    ((e = this._$ES) !== null && e !== void 0 ? e : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) === null || i === void 0 || i.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return wc(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EO(t, e, i = Fi) {
    var r;
    const n = this.constructor._$Ep(t, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) === null || r === void 0 ? void 0 : r.toAttribute) !== void 0 ? i.converter : xr).toAttribute(e, i.type);
      this._$El = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null;
    }
  }
  _$AK(t, e) {
    var i;
    const r = this.constructor, n = r._$Ev.get(t);
    if (n !== void 0 && this._$El !== n) {
      const o = r.getPropertyOptions(n), c = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? o.converter : xr;
      this._$El = n, this[n] = c.fromAttribute(e, o.type), this._$El = null;
    }
  }
  requestUpdate(t, e, i) {
    let r = !0;
    t !== void 0 && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || Qo)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, i))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((r, n) => this[n] = r), this._$Ei = void 0);
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
        var n;
        return (n = r.hostUpdate) === null || n === void 0 ? void 0 : n.call(r);
      }), this.update(i)) : this._$Ek();
    } catch (r) {
      throw e = !1, this._$Ek(), r;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) === null || r === void 0 ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((e, i) => this._$EO(i, this[i], e)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Et[Tr] = !0, Et.elementProperties = /* @__PURE__ */ new Map(), Et.elementStyles = [], Et.shadowRootOptions = { mode: "open" }, Sn == null || Sn({ ReactiveElement: Et }), ((ji = Je.reactiveElementVersions) !== null && ji !== void 0 ? ji : Je.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Vi;
const Qe = window, Dt = Qe.trustedTypes, En = Dt ? Dt.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Rr = "$lit$", z = `lit$${(Math.random() + "").slice(9)}$`, ta = "?" + z, Tc = `<${ta}>`, ft = document, fe = () => ft.createComment(""), me = (s) => s === null || typeof s != "object" && typeof s != "function", ea = Array.isArray, Rc = (s) => ea(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", Wi = `[ 	
\f\r]`, te = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Cn = /-->/g, wn = />/g, Z = RegExp(`>|${Wi}(?:([^\\s"'>=/]+)(${Wi}*=${Wi}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), xn = /'/g, Tn = /"/g, ia = /^(?:script|style|textarea|title)$/i, Pc = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), Y = Pc(1), mt = Symbol.for("lit-noChange"), C = Symbol.for("lit-nothing"), Rn = /* @__PURE__ */ new WeakMap(), st = ft.createTreeWalker(ft, 129, null, !1);
function ra(s, t) {
  if (!Array.isArray(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return En !== void 0 ? En.createHTML(t) : t;
}
const Oc = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : "", o = te;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === te ? h[1] === "!--" ? o = Cn : h[1] !== void 0 ? o = wn : h[2] !== void 0 ? (ia.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = Z) : h[3] !== void 0 && (o = Z) : o === Z ? h[0] === ">" ? (o = r ?? te, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? Z : h[3] === '"' ? Tn : xn) : o === Tn || o === xn ? o = Z : o === Cn || o === wn ? o = te : (o = Z, r = void 0);
    const u = o === Z && s[c + 1].startsWith("/>") ? " " : "";
    n += o === te ? a + Tc : d >= 0 ? (i.push(l), a.slice(0, d) + Rr + a.slice(d) + z + u) : a + z + (d === -2 ? (i.push(void 0), c) : u);
  }
  return [ra(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : "")), i];
};
let Pr = class sa {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = Oc(t, e);
    if (this.el = sa.createElement(l, i), st.currentNode = this.el.content, e === 2) {
      const d = this.el.content, p = d.firstChild;
      p.remove(), d.append(...p.childNodes);
    }
    for (; (r = st.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) {
          const d = [];
          for (const p of r.getAttributeNames()) if (p.endsWith(Rr) || p.startsWith(z)) {
            const u = h[o++];
            if (d.push(p), u !== void 0) {
              const v = r.getAttribute(u.toLowerCase() + Rr).split(z), m = /([.?@])?(.*)/.exec(u);
              a.push({ type: 1, index: n, name: m[2], strings: v, ctor: m[1] === "." ? Hc : m[1] === "?" ? Lc : m[1] === "@" ? Ic : ci });
            } else a.push({ type: 6, index: n });
          }
          for (const p of d) r.removeAttribute(p);
        }
        if (ia.test(r.tagName)) {
          const d = r.textContent.split(z), p = d.length - 1;
          if (p > 0) {
            r.textContent = Dt ? Dt.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], fe()), st.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], fe());
          }
        }
      } else if (r.nodeType === 8) if (r.data === ta) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(z, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += z.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = ft.createElement("template");
    return i.innerHTML = t, i;
  }
};
function zt(s, t, e = s, i) {
  var r, n, o, c;
  if (t === mt) return t;
  let a = i !== void 0 ? (r = e._$Co) === null || r === void 0 ? void 0 : r[i] : e._$Cl;
  const l = me(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== l && ((n = a == null ? void 0 : a._$AO) === null || n === void 0 || n.call(a, !1), l === void 0 ? a = void 0 : (a = new l(s), a._$AT(s, e, i)), i !== void 0 ? ((o = (c = e)._$Co) !== null && o !== void 0 ? o : c._$Co = [])[i] = a : e._$Cl = a), a !== void 0 && (t = zt(s, a._$AS(s, t.values), a, i)), t;
}
let kc = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var e;
    const { el: { content: i }, parts: r } = this._$AD, n = ((e = t == null ? void 0 : t.creationScope) !== null && e !== void 0 ? e : ft).importNode(i, !0);
    st.currentNode = n;
    let o = st.nextNode(), c = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (c === l.index) {
        let h;
        l.type === 2 ? h = new as(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new Mc(o, this, t)), this._$AV.push(h), l = r[++a];
      }
      c !== (l == null ? void 0 : l.index) && (o = st.nextNode(), c++);
    }
    return st.currentNode = ft, n;
  }
  v(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, as = class na {
  constructor(t, e, i, r) {
    var n;
    this.type = 2, this._$AH = C, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cp = (n = r == null ? void 0 : r.isConnected) === null || n === void 0 || n;
  }
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && e !== void 0 ? e : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = zt(this, t, e), me(t) ? t === C || t == null || t === "" ? (this._$AH !== C && this._$AR(), this._$AH = C) : t !== this._$AH && t !== mt && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : Rc(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== C && me(this._$AH) ? this._$AA.nextSibling.data = t : this.$(ft.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var e;
    const { values: i, _$litType$: r } = t, n = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = Pr.createElement(ra(r.h, r.h[0]), this.options)), r);
    if (((e = this._$AH) === null || e === void 0 ? void 0 : e._$AD) === n) this._$AH.v(i);
    else {
      const o = new kc(n, this), c = o.u(this.options);
      o.v(i), this.$(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Rn.get(t.strings);
    return e === void 0 && Rn.set(t.strings, e = new Pr(t)), e;
  }
  T(t) {
    ea(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new na(this.k(fe()), this.k(fe()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cp = t, (e = this._$AP) === null || e === void 0 || e.call(this, t));
  }
}, ci = class {
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = C, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = C;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = zt(this, t, e, 0), o = !me(t) || t !== this._$AH && t !== mt, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = zt(this, c[i + a], e, a), l === mt && (l = this._$AH[a]), o || (o = !me(l) || l !== this._$AH[a]), l === C ? t = C : t !== C && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === C ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, Hc = class extends ci {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === C ? void 0 : t;
  }
};
const Uc = Dt ? Dt.emptyScript : "";
let Lc = class extends ci {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== C ? this.element.setAttribute(this.name, Uc) : this.element.removeAttribute(this.name);
  }
}, Ic = class extends ci {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    var i;
    if ((t = (i = zt(this, t, e, 0)) !== null && i !== void 0 ? i : C) === mt) return;
    const r = this._$AH, n = t === C && r !== C || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== C && (r === C || n);
    n && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, i;
    typeof this._$AH == "function" ? this._$AH.call((i = (e = this.options) === null || e === void 0 ? void 0 : e.host) !== null && i !== void 0 ? i : this.element, t) : this._$AH.handleEvent(t);
  }
}, Mc = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    zt(this, t);
  }
};
const Pn = Qe.litHtmlPolyfillSupport;
Pn == null || Pn(Pr, as), ((Vi = Qe.litHtmlVersions) !== null && Vi !== void 0 ? Vi : Qe.litHtmlVersions = []).push("2.8.0");
const Nc = (s, t, e) => {
  var i, r;
  const n = (i = e == null ? void 0 : e.renderBefore) !== null && i !== void 0 ? i : t;
  let o = n._$litPart$;
  if (o === void 0) {
    const c = (r = e == null ? void 0 : e.renderBefore) !== null && r !== void 0 ? r : null;
    n._$litPart$ = o = new as(t.insertBefore(fe(), c), c, void 0, e ?? {});
  }
  return o._$AI(s), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Ki, Gi;
let ze = class extends Et {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (t = (e = this.renderOptions).renderBefore) !== null && t !== void 0 || (e.renderBefore = i.firstChild), i;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Nc(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return mt;
  }
};
ze.finalized = !0, ze._$litElement$ = !0, (Ki = globalThis.litElementHydrateSupport) === null || Ki === void 0 || Ki.call(globalThis, { LitElement: ze });
const On = globalThis.litElementPolyfillSupport;
On == null || On({ LitElement: ze });
((Gi = globalThis.litElementVersions) !== null && Gi !== void 0 ? Gi : globalThis.litElementVersions = []).push("3.3.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Dc = { ATTRIBUTE: 1 }, zc = (s) => (...t) => ({ _$litDirective$: s, values: t });
let Bc = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const jc = zc(class extends Bc {
  constructor(s) {
    var t;
    if (super(s), s.type !== Dc.ATTRIBUTE || s.name !== "class" || ((t = s.strings) === null || t === void 0 ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return " " + Object.keys(s).filter((t) => s[t]).join(" ") + " ";
  }
  update(s, [t]) {
    var e, i;
    if (this.it === void 0) {
      this.it = /* @__PURE__ */ new Set(), s.strings !== void 0 && (this.nt = new Set(s.strings.join(" ").split(/\s/).filter((n) => n !== "")));
      for (const n in t) t[n] && !(!((e = this.nt) === null || e === void 0) && e.has(n)) && this.it.add(n);
      return this.render(t);
    }
    const r = s.element.classList;
    this.it.forEach((n) => {
      n in t || (r.remove(n), this.it.delete(n));
    });
    for (const n in t) {
      const o = !!t[n];
      o === this.it.has(n) || !((i = this.nt) === null || i === void 0) && i.has(n) || (o ? (r.add(n), this.it.add(n)) : (r.remove(n), this.it.delete(n)));
    }
    return mt;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let Fc = 0;
class _ extends be {
  constructor() {
    super(...arguments), this.mdcFoundationClass = _n, this.label = "", this.icon = "", this.hasImageIcon = !1, this.isFadingIndicator = !1, this.minWidth = !1, this.isMinWidthIndicator = !1, this.indicatorIcon = "", this.stacked = !1, this.focusOnActivate = !0, this._active = !1, this.initFocus = !1, this.shouldRenderRipple = !1, this.useStateLayerCustomProperties = !1, this.rippleElement = null, this.rippleHandlers = new Sc(() => (this.shouldRenderRipple = !0, this.ripple.then((t) => this.rippleElement = t), this.ripple));
  }
  get active() {
    return this._active;
  }
  connectedCallback() {
    this.dir = document.dir, super.connectedCallback();
  }
  firstUpdated() {
    super.firstUpdated(), this.id = this.id || `mdc-tab-${++Fc}`;
  }
  render() {
    const t = {
      "mdc-tab--min-width": this.minWidth,
      "mdc-tab--stacked": this.stacked
    };
    let e = Y``;
    (this.hasImageIcon || this.icon) && (e = Y`
        <span class="mdc-tab__icon material-icons"><slot name="icon">${this.icon}</slot></span>`);
    let i = Y``;
    return this.label && (i = Y`
        <span class="mdc-tab__text-label">${this.label}</span>`), Y`
      <button
        @click="${this.handleClick}"
        class="mdc-tab ${jc(t)}"
        role="tab"
        aria-selected="false"
        tabindex="-1"
        @focus="${this.focus}"
        @blur="${this.handleBlur}"
        @mousedown="${this.handleRippleMouseDown}"
        @mouseenter="${this.handleRippleMouseEnter}"
        @mouseleave="${this.handleRippleMouseLeave}"
        @touchstart="${this.handleRippleTouchStart}"
        @touchend="${this.handleRippleDeactivate}"
        @touchcancel="${this.handleRippleDeactivate}">
        <span class="mdc-tab__content">
          ${e}
          ${i}
          ${this.isMinWidthIndicator ? this.renderIndicator() : ""}
        </span>
        ${this.isMinWidthIndicator ? "" : this.renderIndicator()}
        ${this.renderRipple()}
      </button>`;
  }
  renderIndicator() {
    return Y`<mwc-tab-indicator
        .icon="${this.indicatorIcon}"
        .fade="${this.isFadingIndicator}"></mwc-tab-indicator>`;
  }
  // TODO(dfreedm): Make this use selected as a param after Polymer/internal#739
  /** @soyCompatible */
  renderRipple() {
    return this.shouldRenderRipple ? Y`<mwc-ripple primary
        .internalUseStateLayerCustomProperties="${this.useStateLayerCustomProperties}"></mwc-ripple>` : "";
  }
  createAdapter() {
    return Object.assign(Object.assign({}, Jr(this.mdcRoot)), { setAttr: (t, e) => this.mdcRoot.setAttribute(t, e), activateIndicator: async (t) => {
      await this.tabIndicator.updateComplete, this.tabIndicator.activate(t);
    }, deactivateIndicator: async () => {
      await this.tabIndicator.updateComplete, this.tabIndicator.deactivate();
    }, notifyInteracted: () => this.dispatchEvent(new CustomEvent(_n.strings.INTERACTED_EVENT, {
      detail: { tabId: this.id },
      bubbles: !0,
      composed: !0,
      cancelable: !0
    })), getOffsetLeft: () => this.offsetLeft, getOffsetWidth: () => this.mdcRoot.offsetWidth, getContentOffsetLeft: () => this._contentElement.offsetLeft, getContentOffsetWidth: () => this._contentElement.offsetWidth, focus: () => {
      this.initFocus ? this.initFocus = !1 : this.mdcRoot.focus();
    } });
  }
  activate(t) {
    t || (this.initFocus = !0), this.mdcFoundation ? (this.mdcFoundation.activate(t), this.setActive(this.mdcFoundation.isActive())) : this.updateComplete.then(() => {
      this.mdcFoundation.activate(t), this.setActive(this.mdcFoundation.isActive());
    });
  }
  deactivate() {
    this.mdcFoundation.deactivate(), this.setActive(this.mdcFoundation.isActive());
  }
  setActive(t) {
    const e = this.active;
    e !== t && (this._active = t, this.requestUpdate("active", e));
  }
  computeDimensions() {
    return this.mdcFoundation.computeDimensions();
  }
  computeIndicatorClientRect() {
    return this.tabIndicator.computeContentClientRect();
  }
  // NOTE: needed only for ShadyDOM where delegatesFocus is not implemented
  focus() {
    this.mdcRoot.focus(), this.handleFocus();
  }
  handleClick() {
    this.handleFocus(), this.mdcFoundation.handleClick();
  }
  handleFocus() {
    this.handleRippleFocus();
  }
  handleBlur() {
    this.handleRippleBlur();
  }
  handleRippleMouseDown(t) {
    const e = () => {
      window.removeEventListener("mouseup", e), this.handleRippleDeactivate();
    };
    window.addEventListener("mouseup", e), this.rippleHandlers.startPress(t);
  }
  handleRippleTouchStart(t) {
    this.rippleHandlers.startPress(t);
  }
  handleRippleDeactivate() {
    this.rippleHandlers.endPress();
  }
  handleRippleMouseEnter() {
    this.rippleHandlers.startHover();
  }
  handleRippleMouseLeave() {
    this.rippleHandlers.endHover();
  }
  handleRippleFocus() {
    this.rippleHandlers.startFocus();
  }
  handleRippleBlur() {
    this.rippleHandlers.endFocus();
  }
  get isRippleActive() {
    var t;
    return ((t = this.rippleElement) === null || t === void 0 ? void 0 : t.isActive) || !1;
  }
}
_.shadowRootOptions = { mode: "open", delegatesFocus: !0 };
f([
  Xr(".mdc-tab")
], _.prototype, "mdcRoot", void 0);
f([
  Xr("mwc-tab-indicator")
], _.prototype, "tabIndicator", void 0);
f([
  k()
], _.prototype, "label", void 0);
f([
  k()
], _.prototype, "icon", void 0);
f([
  k({ type: Boolean })
], _.prototype, "hasImageIcon", void 0);
f([
  k({ type: Boolean })
], _.prototype, "isFadingIndicator", void 0);
f([
  k({ type: Boolean })
], _.prototype, "minWidth", void 0);
f([
  k({ type: Boolean })
], _.prototype, "isMinWidthIndicator", void 0);
f([
  k({ type: Boolean, reflect: !0, attribute: "active" })
], _.prototype, "active", null);
f([
  k()
], _.prototype, "indicatorIcon", void 0);
f([
  k({ type: Boolean })
], _.prototype, "stacked", void 0);
f([
  Yo(async function(s) {
    await this.updateComplete, this.mdcFoundation.setFocusOnActivate(s);
  }),
  k({ type: Boolean })
], _.prototype, "focusOnActivate", void 0);
f([
  Xr(".mdc-tab__content")
], _.prototype, "_contentElement", void 0);
f([
  $o()
], _.prototype, "shouldRenderRipple", void 0);
f([
  $o()
], _.prototype, "useStateLayerCustomProperties", void 0);
f([
  sl("mwc-ripple")
], _.prototype, "ripple", void 0);
f([
  rl({ passive: !0 })
], _.prototype, "handleRippleTouchStart", null);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const Vc = Cc`.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}.mdc-tab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-button-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-button-font-size, 0.875rem);line-height:2.25rem;line-height:var(--mdc-typography-button-line-height, 2.25rem);font-weight:500;font-weight:var(--mdc-typography-button-font-weight, 500);letter-spacing:0.0892857143em;letter-spacing:var(--mdc-typography-button-letter-spacing, 0.0892857143em);text-decoration:none;text-decoration:var(--mdc-typography-button-text-decoration, none);text-transform:uppercase;text-transform:var(--mdc-typography-button-text-transform, uppercase);position:relative}.mdc-tab .mdc-tab__text-label{color:rgba(0, 0, 0, 0.6)}.mdc-tab .mdc-tab__icon{color:rgba(0, 0, 0, 0.54);fill:currentColor}.mdc-tab.mdc-ripple-upgraded--background-focused.mdc-tab--active .mdc-tab__focus-ring,.mdc-tab:not(.mdc-ripple-upgraded):focus.mdc-tab--active .mdc-tab__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:8px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc( 100% + -12px );width:calc( 100% + -8px );margin-top:-2px;z-index:2}@media screen and (forced-colors: active){.mdc-tab.mdc-ripple-upgraded--background-focused.mdc-tab--active .mdc-tab__focus-ring,.mdc-tab:not(.mdc-ripple-upgraded):focus.mdc-tab--active .mdc-tab__focus-ring{border-color:CanvasText}}.mdc-tab.mdc-ripple-upgraded--background-focused.mdc-tab--active .mdc-tab__focus-ring::after,.mdc-tab:not(.mdc-ripple-upgraded):focus.mdc-tab--active .mdc-tab__focus-ring::after{content:"";border:2px solid transparent;border-radius:10px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-tab.mdc-ripple-upgraded--background-focused.mdc-tab--active .mdc-tab__focus-ring::after,.mdc-tab:not(.mdc-ripple-upgraded):focus.mdc-tab--active .mdc-tab__focus-ring::after{border-color:CanvasText}}.mdc-tab.mdc-ripple-upgraded--background-focused .mdc-tab__focus-ring,.mdc-tab:not(.mdc-ripple-upgraded):focus .mdc-tab__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:8px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc( 100% + -8px );width:calc( 100% + -8px );z-index:2}@media screen and (forced-colors: active){.mdc-tab.mdc-ripple-upgraded--background-focused .mdc-tab__focus-ring,.mdc-tab:not(.mdc-ripple-upgraded):focus .mdc-tab__focus-ring{border-color:CanvasText}}.mdc-tab.mdc-ripple-upgraded--background-focused .mdc-tab__focus-ring::after,.mdc-tab:not(.mdc-ripple-upgraded):focus .mdc-tab__focus-ring::after{content:"";border:2px solid transparent;border-radius:10px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-tab.mdc-ripple-upgraded--background-focused .mdc-tab__focus-ring::after,.mdc-tab:not(.mdc-ripple-upgraded):focus .mdc-tab__focus-ring::after{border-color:CanvasText}}.mdc-tab__content{position:relative}.mdc-tab__icon{width:24px;height:24px;font-size:24px}.mdc-tab--active .mdc-tab__text-label{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-tab--active .mdc-tab__icon{color:#6200ee;color:var(--mdc-theme-primary, #6200ee);fill:currentColor}.mdc-tab{background:none}.mdc-tab{min-width:90px;padding-right:24px;padding-left:24px;display:flex;flex:1 0 auto;justify-content:center;box-sizing:border-box;margin:0;padding-top:0;padding-bottom:0;border:none;outline:none;text-align:center;white-space:nowrap;cursor:pointer;-webkit-appearance:none;z-index:1}.mdc-tab::-moz-focus-inner{padding:0;border:0}.mdc-tab--min-width{flex:0 1 auto}.mdc-tab__content{display:flex;align-items:center;justify-content:center;height:inherit;pointer-events:none}.mdc-tab__text-label{transition:150ms color linear;display:inline-block;line-height:1;z-index:2}.mdc-tab__icon{transition:150ms color linear;z-index:2}.mdc-tab--stacked .mdc-tab__content{flex-direction:column;align-items:center;justify-content:center}.mdc-tab--stacked .mdc-tab__text-label{padding-top:6px;padding-bottom:4px}.mdc-tab--active .mdc-tab__text-label,.mdc-tab--active .mdc-tab__icon{transition-delay:100ms}.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label{padding-left:8px;padding-right:0}[dir=rtl] .mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label,.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label[dir=rtl]{padding-left:0;padding-right:8px}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-tab{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-tab .mdc-tab__ripple::before,.mdc-tab .mdc-tab__ripple::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-tab .mdc-tab__ripple::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index, 1)}.mdc-tab .mdc-tab__ripple::after{z-index:0;z-index:var(--mdc-ripple-z-index, 0)}.mdc-tab.mdc-ripple-upgraded .mdc-tab__ripple::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-tab.mdc-ripple-upgraded .mdc-tab__ripple::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-tab.mdc-ripple-upgraded--unbounded .mdc-tab__ripple::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-tab.mdc-ripple-upgraded--foreground-activation .mdc-tab__ripple::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-tab.mdc-ripple-upgraded--foreground-deactivation .mdc-tab__ripple::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-tab .mdc-tab__ripple::before,.mdc-tab .mdc-tab__ripple::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-tab.mdc-ripple-upgraded .mdc-tab__ripple::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-tab .mdc-tab__ripple::before,.mdc-tab .mdc-tab__ripple::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-tab:hover .mdc-tab__ripple::before,.mdc-tab.mdc-ripple-surface--hover .mdc-tab__ripple::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-tab.mdc-ripple-upgraded--background-focused .mdc-tab__ripple::before,.mdc-tab:not(.mdc-ripple-upgraded):focus .mdc-tab__ripple::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-tab:not(.mdc-ripple-upgraded) .mdc-tab__ripple::after{transition:opacity 150ms linear}.mdc-tab:not(.mdc-ripple-upgraded):active .mdc-tab__ripple::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-tab.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-tab__ripple{position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden;will-change:transform,opacity}:host{outline:none;flex:1 0 auto;display:flex;justify-content:center;-webkit-tap-highlight-color:transparent}.mdc-tab{height:var(--mdc-tab-height, 48px);margin-left:0;margin-right:0;padding-right:var(--mdc-tab-horizontal-padding, 24px);padding-left:var(--mdc-tab-horizontal-padding, 24px)}.mdc-tab--stacked{height:var(--mdc-tab-stacked-height, 72px)}.mdc-tab::-moz-focus-inner{border:0}.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label{padding-left:8px;padding-right:0}[dir=rtl] .mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label,.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label[dir=rtl]{padding-left:0;padding-right:8px}.mdc-tab:not(.mdc-tab--active) .mdc-tab__text-label{color:var(--mdc-tab-text-label-color-default, rgba(0, 0, 0, 0.6))}.mdc-tab:not(.mdc-tab--active) .mdc-tab__icon{color:var(--mdc-tab-color-default, rgba(0, 0, 0, 0.54))}`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let Or = class extends _ {
};
Or.styles = [Vc];
Or = f([
  tl("mwc-tab")
], Or);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Wc = (s) => (t) => typeof t == "function" ? ((e, i) => (customElements.define(e, i), i))(s, t) : ((e, i) => {
  const { kind: r, elements: n } = i;
  return { kind: r, elements: n, finisher(o) {
    customElements.define(e, o);
  } };
})(s, t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const oa = ({ finisher: s, descriptor: t }) => (e, i) => {
  var r;
  if (i === void 0) {
    const n = (r = e.originalKey) !== null && r !== void 0 ? r : e.key, o = t != null ? { kind: "method", placement: "prototype", key: n, descriptor: t(e.key) } : { ...e, key: n };
    return s != null && (o.finisher = function(c) {
      s(c, n);
    }), o;
  }
  {
    const n = e.constructor;
    t !== void 0 && Object.defineProperty(e, i, t(i)), s == null || s(n, i);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Kc(s) {
  return oa({ finisher: (t, e) => {
    Object.assign(t.prototype[e], s);
  } });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function ls(s, t) {
  return oa({ descriptor: (e) => ({ get() {
    var r, n;
    return (n = (r = this.renderRoot) === null || r === void 0 ? void 0 : r.querySelector(s)) !== null && n !== void 0 ? n : null;
  }, enumerable: !0, configurable: !0 }) });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var qi;
((qi = window.HTMLSlotElement) === null || qi === void 0 ? void 0 : qi.prototype.assignedElements) != null;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Gc = {
  ANIMATING: "mdc-tab-scroller--animating",
  SCROLL_AREA_SCROLL: "mdc-tab-scroller__scroll-area--scroll",
  SCROLL_TEST: "mdc-tab-scroller__test"
}, qc = {
  AREA_SELECTOR: ".mdc-tab-scroller__scroll-area",
  CONTENT_SELECTOR: ".mdc-tab-scroller__scroll-content"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cs = (
  /** @class */
  /* @__PURE__ */ function() {
    function s(t) {
      this.adapter = t;
    }
    return s;
  }()
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Xc = (
  /** @class */
  function(s) {
    H(t, s);
    function t() {
      return s !== null && s.apply(this, arguments) || this;
    }
    return t.prototype.getScrollPositionRTL = function() {
      var e = this.adapter.getScrollAreaScrollLeft(), i = this.calculateScrollEdges().right;
      return Math.round(i - e);
    }, t.prototype.scrollToRTL = function(e) {
      var i = this.calculateScrollEdges(), r = this.adapter.getScrollAreaScrollLeft(), n = this.clampScrollValue(i.right - e);
      return {
        finalScrollPosition: n,
        scrollDelta: n - r
      };
    }, t.prototype.incrementScrollRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft(), r = this.clampScrollValue(i - e);
      return {
        finalScrollPosition: r,
        scrollDelta: r - i
      };
    }, t.prototype.getAnimatingScrollPosition = function(e) {
      return e;
    }, t.prototype.calculateScrollEdges = function() {
      var e = this.adapter.getScrollContentOffsetWidth(), i = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: 0,
        right: e - i
      };
    }, t.prototype.clampScrollValue = function(e) {
      var i = this.calculateScrollEdges();
      return Math.min(Math.max(i.left, e), i.right);
    }, t;
  }(cs)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Zc = (
  /** @class */
  function(s) {
    H(t, s);
    function t() {
      return s !== null && s.apply(this, arguments) || this;
    }
    return t.prototype.getScrollPositionRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft();
      return Math.round(e - i);
    }, t.prototype.scrollToRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft(), r = this.clampScrollValue(-e);
      return {
        finalScrollPosition: r,
        scrollDelta: r - i
      };
    }, t.prototype.incrementScrollRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft(), r = this.clampScrollValue(i - e);
      return {
        finalScrollPosition: r,
        scrollDelta: r - i
      };
    }, t.prototype.getAnimatingScrollPosition = function(e, i) {
      return e - i;
    }, t.prototype.calculateScrollEdges = function() {
      var e = this.adapter.getScrollContentOffsetWidth(), i = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: i - e,
        right: 0
      };
    }, t.prototype.clampScrollValue = function(e) {
      var i = this.calculateScrollEdges();
      return Math.max(Math.min(i.right, e), i.left);
    }, t;
  }(cs)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Yc = (
  /** @class */
  function(s) {
    H(t, s);
    function t() {
      return s !== null && s.apply(this, arguments) || this;
    }
    return t.prototype.getScrollPositionRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft();
      return Math.round(i - e);
    }, t.prototype.scrollToRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft(), r = this.clampScrollValue(e);
      return {
        finalScrollPosition: r,
        scrollDelta: i - r
      };
    }, t.prototype.incrementScrollRTL = function(e) {
      var i = this.adapter.getScrollAreaScrollLeft(), r = this.clampScrollValue(i + e);
      return {
        finalScrollPosition: r,
        scrollDelta: i - r
      };
    }, t.prototype.getAnimatingScrollPosition = function(e, i) {
      return e + i;
    }, t.prototype.calculateScrollEdges = function() {
      var e = this.adapter.getScrollContentOffsetWidth(), i = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: e - i,
        right: 0
      };
    }, t.prototype.clampScrollValue = function(e) {
      var i = this.calculateScrollEdges();
      return Math.min(Math.max(i.right, e), i.left);
    }, t;
  }(cs)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Jc = (
  /** @class */
  function(s) {
    H(t, s);
    function t(e) {
      var i = s.call(this, R(R({}, t.defaultAdapter), e)) || this;
      return i.isAnimating = !1, i;
    }
    return Object.defineProperty(t, "cssClasses", {
      get: function() {
        return Gc;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "strings", {
      get: function() {
        return qc;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultAdapter", {
      get: function() {
        return {
          eventTargetMatchesSelector: function() {
            return !1;
          },
          addClass: function() {
          },
          removeClass: function() {
          },
          addScrollAreaClass: function() {
          },
          setScrollAreaStyleProperty: function() {
          },
          setScrollContentStyleProperty: function() {
          },
          getScrollContentStyleValue: function() {
            return "";
          },
          setScrollAreaScrollLeft: function() {
          },
          getScrollAreaScrollLeft: function() {
            return 0;
          },
          getScrollContentOffsetWidth: function() {
            return 0;
          },
          getScrollAreaOffsetWidth: function() {
            return 0;
          },
          computeScrollAreaClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          computeScrollContentClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          computeHorizontalScrollbarHeight: function() {
            return 0;
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.init = function() {
      var e = this.adapter.computeHorizontalScrollbarHeight();
      this.adapter.setScrollAreaStyleProperty("margin-bottom", -e + "px"), this.adapter.addScrollAreaClass(t.cssClasses.SCROLL_AREA_SCROLL);
    }, t.prototype.getScrollPosition = function() {
      if (this.isRTL())
        return this.computeCurrentScrollPositionRTL();
      var e = this.calculateCurrentTranslateX(), i = this.adapter.getScrollAreaScrollLeft();
      return i - e;
    }, t.prototype.handleInteraction = function() {
      this.isAnimating && this.stopScrollAnimation();
    }, t.prototype.handleTransitionEnd = function(e) {
      var i = e.target;
      !this.isAnimating || !this.adapter.eventTargetMatchesSelector(i, t.strings.CONTENT_SELECTOR) || (this.isAnimating = !1, this.adapter.removeClass(t.cssClasses.ANIMATING));
    }, t.prototype.incrementScroll = function(e) {
      e !== 0 && this.animate(this.getIncrementScrollOperation(e));
    }, t.prototype.incrementScrollImmediate = function(e) {
      if (e !== 0) {
        var i = this.getIncrementScrollOperation(e);
        i.scrollDelta !== 0 && (this.stopScrollAnimation(), this.adapter.setScrollAreaScrollLeft(i.finalScrollPosition));
      }
    }, t.prototype.scrollTo = function(e) {
      if (this.isRTL()) {
        this.scrollToImplRTL(e);
        return;
      }
      this.scrollToImpl(e);
    }, t.prototype.getRTLScroller = function() {
      return this.rtlScrollerInstance || (this.rtlScrollerInstance = this.rtlScrollerFactory()), this.rtlScrollerInstance;
    }, t.prototype.calculateCurrentTranslateX = function() {
      var e = this.adapter.getScrollContentStyleValue("transform");
      if (e === "none")
        return 0;
      var i = /\((.+?)\)/.exec(e);
      if (!i)
        return 0;
      var r = i[1], n = qa(r.split(","), 6);
      n[0], n[1], n[2], n[3];
      var o = n[4];
      return n[5], parseFloat(o);
    }, t.prototype.clampScrollValue = function(e) {
      var i = this.calculateScrollEdges();
      return Math.min(Math.max(i.left, e), i.right);
    }, t.prototype.computeCurrentScrollPositionRTL = function() {
      var e = this.calculateCurrentTranslateX();
      return this.getRTLScroller().getScrollPositionRTL(e);
    }, t.prototype.calculateScrollEdges = function() {
      var e = this.adapter.getScrollContentOffsetWidth(), i = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: 0,
        right: e - i
      };
    }, t.prototype.scrollToImpl = function(e) {
      var i = this.getScrollPosition(), r = this.clampScrollValue(e), n = r - i;
      this.animate({
        finalScrollPosition: r,
        scrollDelta: n
      });
    }, t.prototype.scrollToImplRTL = function(e) {
      var i = this.getRTLScroller().scrollToRTL(e);
      this.animate(i);
    }, t.prototype.getIncrementScrollOperation = function(e) {
      if (this.isRTL())
        return this.getRTLScroller().incrementScrollRTL(e);
      var i = this.getScrollPosition(), r = e + i, n = this.clampScrollValue(r), o = n - i;
      return {
        finalScrollPosition: n,
        scrollDelta: o
      };
    }, t.prototype.animate = function(e) {
      var i = this;
      e.scrollDelta !== 0 && (this.stopScrollAnimation(), this.adapter.setScrollAreaScrollLeft(e.finalScrollPosition), this.adapter.setScrollContentStyleProperty("transform", "translateX(" + e.scrollDelta + "px)"), this.adapter.computeScrollAreaClientRect(), requestAnimationFrame(function() {
        i.adapter.addClass(t.cssClasses.ANIMATING), i.adapter.setScrollContentStyleProperty("transform", "none");
      }), this.isAnimating = !0);
    }, t.prototype.stopScrollAnimation = function() {
      this.isAnimating = !1;
      var e = this.getAnimatingScrollPosition();
      this.adapter.removeClass(t.cssClasses.ANIMATING), this.adapter.setScrollContentStyleProperty("transform", "translateX(0px)"), this.adapter.setScrollAreaScrollLeft(e);
    }, t.prototype.getAnimatingScrollPosition = function() {
      var e = this.calculateCurrentTranslateX(), i = this.adapter.getScrollAreaScrollLeft();
      return this.isRTL() ? this.getRTLScroller().getAnimatingScrollPosition(i, e) : i - e;
    }, t.prototype.rtlScrollerFactory = function() {
      var e = this.adapter.getScrollAreaScrollLeft();
      this.adapter.setScrollAreaScrollLeft(e - 1);
      var i = this.adapter.getScrollAreaScrollLeft();
      if (i < 0)
        return this.adapter.setScrollAreaScrollLeft(e), new Zc(this.adapter);
      var r = this.adapter.computeScrollAreaClientRect(), n = this.adapter.computeScrollContentClientRect(), o = Math.round(n.right - r.right);
      return this.adapter.setScrollAreaScrollLeft(e), o === i ? new Yc(this.adapter) : new Xc(this.adapter);
    }, t.prototype.isRTL = function() {
      return this.adapter.getScrollContentStyleValue("direction") === "rtl";
    }, t;
  }(Ae)
);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Be = window, ds = Be.ShadowRoot && (Be.ShadyCSS === void 0 || Be.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, hs = Symbol(), kn = /* @__PURE__ */ new WeakMap();
let aa = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== hs) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (ds && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = kn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && kn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Qc = (s) => new aa(typeof s == "string" ? s : s + "", void 0, hs), td = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new aa(e, s, hs);
}, ed = (s, t) => {
  ds ? s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach((e) => {
    const i = document.createElement("style"), r = Be.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  });
}, Hn = ds ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return Qc(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Xi;
const ti = window, Un = ti.trustedTypes, id = Un ? Un.emptyScript : "", Ln = ti.reactiveElementPolyfillSupport, kr = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? id : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, la = (s, t) => t !== s && (t == t || s == s), Zi = { attribute: !0, type: String, converter: kr, reflect: !1, hasChanged: la }, Hr = "finalized";
let Ct = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(t) {
    var e;
    this.finalize(), ((e = this.h) !== null && e !== void 0 ? e : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((e, i) => {
      const r = this._$Ep(i, e);
      r !== void 0 && (this._$Ev.set(r, i), t.push(r));
    }), t;
  }
  static createProperty(t, e = Zi) {
    if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const i = typeof t == "symbol" ? Symbol() : "__" + t, r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && Object.defineProperty(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return { get() {
      return this[e];
    }, set(r) {
      const n = this[t];
      this[e] = r, this.requestUpdate(t, n, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || Zi;
  }
  static finalize() {
    if (this.hasOwnProperty(Hr)) return !1;
    this[Hr] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e = this.properties, i = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(Hn(r));
    } else t !== void 0 && e.push(Hn(t));
    return e;
  }
  static _$Ep(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  _$Eu() {
    var t;
    this._$E_ = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((e) => e(this));
  }
  addController(t) {
    var e, i;
    ((e = this._$ES) !== null && e !== void 0 ? e : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) === null || i === void 0 || i.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return ed(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EO(t, e, i = Zi) {
    var r;
    const n = this.constructor._$Ep(t, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) === null || r === void 0 ? void 0 : r.toAttribute) !== void 0 ? i.converter : kr).toAttribute(e, i.type);
      this._$El = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null;
    }
  }
  _$AK(t, e) {
    var i;
    const r = this.constructor, n = r._$Ev.get(t);
    if (n !== void 0 && this._$El !== n) {
      const o = r.getPropertyOptions(n), c = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? o.converter : kr;
      this._$El = n, this[n] = c.fromAttribute(e, o.type), this._$El = null;
    }
  }
  requestUpdate(t, e, i) {
    let r = !0;
    t !== void 0 && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || la)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, i))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((r, n) => this[n] = r), this._$Ei = void 0);
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
        var n;
        return (n = r.hostUpdate) === null || n === void 0 ? void 0 : n.call(r);
      }), this.update(i)) : this._$Ek();
    } catch (r) {
      throw e = !1, this._$Ek(), r;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) === null || r === void 0 ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((e, i) => this._$EO(i, this[i], e)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Ct[Hr] = !0, Ct.elementProperties = /* @__PURE__ */ new Map(), Ct.elementStyles = [], Ct.shadowRootOptions = { mode: "open" }, Ln == null || Ln({ ReactiveElement: Ct }), ((Xi = ti.reactiveElementVersions) !== null && Xi !== void 0 ? Xi : ti.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Yi;
const ei = window, Bt = ei.trustedTypes, In = Bt ? Bt.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Ur = "$lit$", B = `lit$${(Math.random() + "").slice(9)}$`, ca = "?" + B, rd = `<${ca}>`, vt = document, ve = () => vt.createComment(""), ge = (s) => s === null || typeof s != "object" && typeof s != "function", da = Array.isArray, sd = (s) => da(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", Ji = `[ 	
\f\r]`, ee = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Mn = /-->/g, Nn = />/g, J = RegExp(`>|${Ji}(?:([^\\s"'>=/]+)(${Ji}*=${Ji}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Dn = /'/g, zn = /"/g, ha = /^(?:script|style|textarea|title)$/i, nd = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), od = nd(1), jt = Symbol.for("lit-noChange"), w = Symbol.for("lit-nothing"), Bn = /* @__PURE__ */ new WeakMap(), nt = vt.createTreeWalker(vt, 129, null, !1);
function pa(s, t) {
  if (!Array.isArray(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return In !== void 0 ? In.createHTML(t) : t;
}
const ad = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : "", o = ee;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === ee ? h[1] === "!--" ? o = Mn : h[1] !== void 0 ? o = Nn : h[2] !== void 0 ? (ha.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = J) : h[3] !== void 0 && (o = J) : o === J ? h[0] === ">" ? (o = r ?? ee, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? J : h[3] === '"' ? zn : Dn) : o === zn || o === Dn ? o = J : o === Mn || o === Nn ? o = ee : (o = J, r = void 0);
    const u = o === J && s[c + 1].startsWith("/>") ? " " : "";
    n += o === ee ? a + rd : d >= 0 ? (i.push(l), a.slice(0, d) + Ur + a.slice(d) + B + u) : a + B + (d === -2 ? (i.push(void 0), c) : u);
  }
  return [pa(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : "")), i];
};
let Lr = class ua {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = ad(t, e);
    if (this.el = ua.createElement(l, i), nt.currentNode = this.el.content, e === 2) {
      const d = this.el.content, p = d.firstChild;
      p.remove(), d.append(...p.childNodes);
    }
    for (; (r = nt.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) {
          const d = [];
          for (const p of r.getAttributeNames()) if (p.endsWith(Ur) || p.startsWith(B)) {
            const u = h[o++];
            if (d.push(p), u !== void 0) {
              const v = r.getAttribute(u.toLowerCase() + Ur).split(B), m = /([.?@])?(.*)/.exec(u);
              a.push({ type: 1, index: n, name: m[2], strings: v, ctor: m[1] === "." ? cd : m[1] === "?" ? hd : m[1] === "@" ? pd : di });
            } else a.push({ type: 6, index: n });
          }
          for (const p of d) r.removeAttribute(p);
        }
        if (ha.test(r.tagName)) {
          const d = r.textContent.split(B), p = d.length - 1;
          if (p > 0) {
            r.textContent = Bt ? Bt.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], ve()), nt.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], ve());
          }
        }
      } else if (r.nodeType === 8) if (r.data === ca) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(B, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += B.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = vt.createElement("template");
    return i.innerHTML = t, i;
  }
};
function Ft(s, t, e = s, i) {
  var r, n, o, c;
  if (t === jt) return t;
  let a = i !== void 0 ? (r = e._$Co) === null || r === void 0 ? void 0 : r[i] : e._$Cl;
  const l = ge(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== l && ((n = a == null ? void 0 : a._$AO) === null || n === void 0 || n.call(a, !1), l === void 0 ? a = void 0 : (a = new l(s), a._$AT(s, e, i)), i !== void 0 ? ((o = (c = e)._$Co) !== null && o !== void 0 ? o : c._$Co = [])[i] = a : e._$Cl = a), a !== void 0 && (t = Ft(s, a._$AS(s, t.values), a, i)), t;
}
let ld = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var e;
    const { el: { content: i }, parts: r } = this._$AD, n = ((e = t == null ? void 0 : t.creationScope) !== null && e !== void 0 ? e : vt).importNode(i, !0);
    nt.currentNode = n;
    let o = nt.nextNode(), c = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (c === l.index) {
        let h;
        l.type === 2 ? h = new ps(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new ud(o, this, t)), this._$AV.push(h), l = r[++a];
      }
      c !== (l == null ? void 0 : l.index) && (o = nt.nextNode(), c++);
    }
    return nt.currentNode = vt, n;
  }
  v(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, ps = class fa {
  constructor(t, e, i, r) {
    var n;
    this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cp = (n = r == null ? void 0 : r.isConnected) === null || n === void 0 || n;
  }
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && e !== void 0 ? e : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Ft(this, t, e), ge(t) ? t === w || t == null || t === "" ? (this._$AH !== w && this._$AR(), this._$AH = w) : t !== this._$AH && t !== jt && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : sd(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== w && ge(this._$AH) ? this._$AA.nextSibling.data = t : this.$(vt.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var e;
    const { values: i, _$litType$: r } = t, n = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = Lr.createElement(pa(r.h, r.h[0]), this.options)), r);
    if (((e = this._$AH) === null || e === void 0 ? void 0 : e._$AD) === n) this._$AH.v(i);
    else {
      const o = new ld(n, this), c = o.u(this.options);
      o.v(i), this.$(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Bn.get(t.strings);
    return e === void 0 && Bn.set(t.strings, e = new Lr(t)), e;
  }
  T(t) {
    da(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new fa(this.k(ve()), this.k(ve()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cp = t, (e = this._$AP) === null || e === void 0 || e.call(this, t));
  }
}, di = class {
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = w;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = Ft(this, t, e, 0), o = !ge(t) || t !== this._$AH && t !== jt, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = Ft(this, c[i + a], e, a), l === jt && (l = this._$AH[a]), o || (o = !ge(l) || l !== this._$AH[a]), l === w ? t = w : t !== w && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, cd = class extends di {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === w ? void 0 : t;
  }
};
const dd = Bt ? Bt.emptyScript : "";
let hd = class extends di {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== w ? this.element.setAttribute(this.name, dd) : this.element.removeAttribute(this.name);
  }
}, pd = class extends di {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    var i;
    if ((t = (i = Ft(this, t, e, 0)) !== null && i !== void 0 ? i : w) === jt) return;
    const r = this._$AH, n = t === w && r !== w || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== w && (r === w || n);
    n && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, i;
    typeof this._$AH == "function" ? this._$AH.call((i = (e = this.options) === null || e === void 0 ? void 0 : e.host) !== null && i !== void 0 ? i : this.element, t) : this._$AH.handleEvent(t);
  }
}, ud = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Ft(this, t);
  }
};
const jn = ei.litHtmlPolyfillSupport;
jn == null || jn(Lr, ps), ((Yi = ei.litHtmlVersions) !== null && Yi !== void 0 ? Yi : ei.litHtmlVersions = []).push("2.8.0");
const fd = (s, t, e) => {
  var i, r;
  const n = (i = e == null ? void 0 : e.renderBefore) !== null && i !== void 0 ? i : t;
  let o = n._$litPart$;
  if (o === void 0) {
    const c = (r = e == null ? void 0 : e.renderBefore) !== null && r !== void 0 ? r : null;
    n._$litPart$ = o = new ps(t.insertBefore(ve(), c), c, void 0, e ?? {});
  }
  return o._$AI(s), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Qi, tr;
let je = class extends Ct {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (t = (e = this.renderOptions).renderBefore) !== null && t !== void 0 || (e.renderBefore = i.firstChild), i;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = fd(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return jt;
  }
};
je.finalized = !0, je._$litElement$ = !0, (Qi = globalThis.litElementHydrateSupport) === null || Qi === void 0 || Qi.call(globalThis, { LitElement: je });
const Fn = globalThis.litElementPolyfillSupport;
Fn == null || Fn({ LitElement: je });
((tr = globalThis.litElementVersions) !== null && tr !== void 0 ? tr : globalThis.litElementVersions = []).push("3.3.3");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Ee extends be {
  constructor() {
    super(...arguments), this.mdcFoundationClass = Jc, this._scrollbarHeight = -1;
  }
  _handleInteraction() {
    this.mdcFoundation.handleInteraction();
  }
  _handleTransitionEnd(t) {
    this.mdcFoundation.handleTransitionEnd(t);
  }
  render() {
    return od`
      <div class="mdc-tab-scroller">
        <div class="mdc-tab-scroller__scroll-area"
            @wheel="${this._handleInteraction}"
            @touchstart="${this._handleInteraction}"
            @pointerdown="${this._handleInteraction}"
            @mousedown="${this._handleInteraction}"
            @keydown="${this._handleInteraction}"
            @transitionend="${this._handleTransitionEnd}">
          <div class="mdc-tab-scroller__scroll-content"><slot></slot></div>
        </div>
      </div>
      `;
  }
  createAdapter() {
    return Object.assign(Object.assign({}, Jr(this.mdcRoot)), { eventTargetMatchesSelector: (t, e) => No(t, e), addScrollAreaClass: (t) => this.scrollAreaElement.classList.add(t), setScrollAreaStyleProperty: (t, e) => this.scrollAreaElement.style.setProperty(t, e), setScrollContentStyleProperty: (t, e) => this.scrollContentElement.style.setProperty(t, e), getScrollContentStyleValue: (t) => window.getComputedStyle(this.scrollContentElement).getPropertyValue(t), setScrollAreaScrollLeft: (t) => this.scrollAreaElement.scrollLeft = t, getScrollAreaScrollLeft: () => this.scrollAreaElement.scrollLeft, getScrollContentOffsetWidth: () => this.scrollContentElement.offsetWidth, getScrollAreaOffsetWidth: () => this.scrollAreaElement.offsetWidth, computeScrollAreaClientRect: () => this.scrollAreaElement.getBoundingClientRect(), computeScrollContentClientRect: () => this.scrollContentElement.getBoundingClientRect(), computeHorizontalScrollbarHeight: () => (this._scrollbarHeight === -1 && (this.scrollAreaElement.style.overflowX = "scroll", this._scrollbarHeight = this.scrollAreaElement.offsetHeight - this.scrollAreaElement.clientHeight, this.scrollAreaElement.style.overflowX = ""), this._scrollbarHeight) });
  }
  /**
   * Returns the current visual scroll position
   * @return {number}
   */
  getScrollPosition() {
    return this.mdcFoundation.getScrollPosition();
  }
  /**
   * Returns the width of the scroll content
   * @return {number}
   */
  getScrollContentWidth() {
    return this.scrollContentElement.offsetWidth;
  }
  /**
   * Increments the scroll value by the given amount
   * @param {number} scrollXIncrement The pixel value by which to increment the
   *     scroll value
   */
  incrementScrollPosition(t) {
    this.mdcFoundation.incrementScroll(t);
  }
  /**
   * Scrolls to the given pixel position
   * @param {number} scrollX The pixel value to scroll to
   */
  scrollToPosition(t) {
    this.mdcFoundation.scrollTo(t);
  }
}
f([
  ls(".mdc-tab-scroller")
], Ee.prototype, "mdcRoot", void 0);
f([
  ls(".mdc-tab-scroller__scroll-area")
], Ee.prototype, "scrollAreaElement", void 0);
f([
  ls(".mdc-tab-scroller__scroll-content")
], Ee.prototype, "scrollContentElement", void 0);
f([
  Kc({ passive: !0 })
], Ee.prototype, "_handleInteraction", null);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const md = td`.mdc-tab-scroller{overflow-y:hidden}.mdc-tab-scroller.mdc-tab-scroller--animating .mdc-tab-scroller__scroll-content{transition:250ms transform cubic-bezier(0.4, 0, 0.2, 1)}.mdc-tab-scroller__test{position:absolute;top:-9999px;width:100px;height:100px;overflow-x:scroll}.mdc-tab-scroller__scroll-area{-webkit-overflow-scrolling:touch;display:flex;overflow-x:hidden}.mdc-tab-scroller__scroll-area::-webkit-scrollbar,.mdc-tab-scroller__test::-webkit-scrollbar{display:none}.mdc-tab-scroller__scroll-area--scroll{overflow-x:scroll}.mdc-tab-scroller__scroll-content{position:relative;display:flex;flex:1 0 auto;transform:none;will-change:transform}.mdc-tab-scroller--align-start .mdc-tab-scroller__scroll-content{justify-content:flex-start}.mdc-tab-scroller--align-end .mdc-tab-scroller__scroll-content{justify-content:flex-end}.mdc-tab-scroller--align-center .mdc-tab-scroller__scroll-content{justify-content:center}.mdc-tab-scroller--animating .mdc-tab-scroller__scroll-area{-webkit-overflow-scrolling:auto}:host{display:flex}.mdc-tab-scroller{flex:1}`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let Ir = class extends Ee {
};
Ir.styles = [md];
Ir = f([
  Wc("mwc-tab-scroller")
], Ir);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var $ = {
  ARROW_LEFT_KEY: "ArrowLeft",
  ARROW_RIGHT_KEY: "ArrowRight",
  END_KEY: "End",
  ENTER_KEY: "Enter",
  HOME_KEY: "Home",
  SPACE_KEY: "Space",
  TAB_ACTIVATED_EVENT: "MDCTabBar:activated",
  TAB_SCROLLER_SELECTOR: ".mdc-tab-scroller",
  TAB_SELECTOR: ".mdc-tab"
}, O = {
  ARROW_LEFT_KEYCODE: 37,
  ARROW_RIGHT_KEYCODE: 39,
  END_KEYCODE: 35,
  ENTER_KEYCODE: 13,
  EXTRA_SCROLL_AMOUNT: 20,
  HOME_KEYCODE: 36,
  SPACE_KEYCODE: 32
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var $t = /* @__PURE__ */ new Set();
$t.add($.ARROW_LEFT_KEY);
$t.add($.ARROW_RIGHT_KEY);
$t.add($.END_KEY);
$t.add($.HOME_KEY);
$t.add($.ENTER_KEY);
$t.add($.SPACE_KEY);
var _t = /* @__PURE__ */ new Map();
_t.set(O.ARROW_LEFT_KEYCODE, $.ARROW_LEFT_KEY);
_t.set(O.ARROW_RIGHT_KEYCODE, $.ARROW_RIGHT_KEY);
_t.set(O.END_KEYCODE, $.END_KEY);
_t.set(O.HOME_KEYCODE, $.HOME_KEY);
_t.set(O.ENTER_KEYCODE, $.ENTER_KEY);
_t.set(O.SPACE_KEYCODE, $.SPACE_KEY);
var Vn = (
  /** @class */
  function(s) {
    H(t, s);
    function t(e) {
      var i = s.call(this, R(R({}, t.defaultAdapter), e)) || this;
      return i.useAutomaticActivation = !1, i;
    }
    return Object.defineProperty(t, "strings", {
      get: function() {
        return $;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "numbers", {
      get: function() {
        return O;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultAdapter", {
      get: function() {
        return {
          scrollTo: function() {
          },
          incrementScroll: function() {
          },
          getScrollPosition: function() {
            return 0;
          },
          getScrollContentWidth: function() {
            return 0;
          },
          getOffsetWidth: function() {
            return 0;
          },
          isRTL: function() {
            return !1;
          },
          setActiveTab: function() {
          },
          activateTabAtIndex: function() {
          },
          deactivateTabAtIndex: function() {
          },
          focusTabAtIndex: function() {
          },
          getTabIndicatorClientRectAtIndex: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          getTabDimensionsAtIndex: function() {
            return { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };
          },
          getPreviousActiveTabIndex: function() {
            return -1;
          },
          getFocusedTabIndex: function() {
            return -1;
          },
          getIndexOfTabById: function() {
            return -1;
          },
          getTabListLength: function() {
            return 0;
          },
          notifyTabActivated: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setUseAutomaticActivation = function(e) {
      this.useAutomaticActivation = e;
    }, t.prototype.activateTab = function(e) {
      var i = this.adapter.getPreviousActiveTabIndex();
      if (!(!this.indexIsInRange(e) || e === i)) {
        var r;
        i !== -1 && (this.adapter.deactivateTabAtIndex(i), r = this.adapter.getTabIndicatorClientRectAtIndex(i)), this.adapter.activateTabAtIndex(e, r), this.scrollIntoView(e), this.adapter.notifyTabActivated(e);
      }
    }, t.prototype.handleKeyDown = function(e) {
      var i = this.getKeyFromEvent(e);
      if (i !== void 0)
        if (this.isActivationKey(i) || e.preventDefault(), this.useAutomaticActivation) {
          if (this.isActivationKey(i))
            return;
          var r = this.determineTargetFromKey(this.adapter.getPreviousActiveTabIndex(), i);
          this.adapter.setActiveTab(r), this.scrollIntoView(r);
        } else {
          var n = this.adapter.getFocusedTabIndex();
          if (this.isActivationKey(i))
            this.adapter.setActiveTab(n);
          else {
            var r = this.determineTargetFromKey(n, i);
            this.adapter.focusTabAtIndex(r), this.scrollIntoView(r);
          }
        }
    }, t.prototype.handleTabInteraction = function(e) {
      this.adapter.setActiveTab(this.adapter.getIndexOfTabById(e.detail.tabId));
    }, t.prototype.scrollIntoView = function(e) {
      if (this.indexIsInRange(e)) {
        if (e === 0) {
          this.adapter.scrollTo(0);
          return;
        }
        if (e === this.adapter.getTabListLength() - 1) {
          this.adapter.scrollTo(this.adapter.getScrollContentWidth());
          return;
        }
        if (this.isRTL()) {
          this.scrollIntoViewImplRTL(e);
          return;
        }
        this.scrollIntoViewImpl(e);
      }
    }, t.prototype.determineTargetFromKey = function(e, i) {
      var r = this.isRTL(), n = this.adapter.getTabListLength() - 1, o = i === $.END_KEY, c = i === $.ARROW_LEFT_KEY && !r || i === $.ARROW_RIGHT_KEY && r, a = i === $.ARROW_RIGHT_KEY && !r || i === $.ARROW_LEFT_KEY && r, l = e;
      return o ? l = n : c ? l -= 1 : a ? l += 1 : l = 0, l < 0 ? l = n : l > n && (l = 0), l;
    }, t.prototype.calculateScrollIncrement = function(e, i, r, n) {
      var o = this.adapter.getTabDimensionsAtIndex(i), c = o.contentLeft - r - n, a = o.contentRight - r, l = a - O.EXTRA_SCROLL_AMOUNT, h = c + O.EXTRA_SCROLL_AMOUNT;
      return i < e ? Math.min(l, 0) : Math.max(h, 0);
    }, t.prototype.calculateScrollIncrementRTL = function(e, i, r, n, o) {
      var c = this.adapter.getTabDimensionsAtIndex(i), a = o - c.contentLeft - r, l = o - c.contentRight - r - n, h = l + O.EXTRA_SCROLL_AMOUNT, d = a - O.EXTRA_SCROLL_AMOUNT;
      return i > e ? Math.max(h, 0) : Math.min(d, 0);
    }, t.prototype.findAdjacentTabIndexClosestToEdge = function(e, i, r, n) {
      var o = i.rootLeft - r, c = i.rootRight - r - n, a = o + c, l = o < 0 || a < 0, h = c > 0 || a > 0;
      return l ? e - 1 : h ? e + 1 : -1;
    }, t.prototype.findAdjacentTabIndexClosestToEdgeRTL = function(e, i, r, n, o) {
      var c = o - i.rootLeft - n - r, a = o - i.rootRight - r, l = c + a, h = c > 0 || l > 0, d = a < 0 || l < 0;
      return h ? e + 1 : d ? e - 1 : -1;
    }, t.prototype.getKeyFromEvent = function(e) {
      return $t.has(e.key) ? e.key : _t.get(e.keyCode);
    }, t.prototype.isActivationKey = function(e) {
      return e === $.SPACE_KEY || e === $.ENTER_KEY;
    }, t.prototype.indexIsInRange = function(e) {
      return e >= 0 && e < this.adapter.getTabListLength();
    }, t.prototype.isRTL = function() {
      return this.adapter.isRTL();
    }, t.prototype.scrollIntoViewImpl = function(e) {
      var i = this.adapter.getScrollPosition(), r = this.adapter.getOffsetWidth(), n = this.adapter.getTabDimensionsAtIndex(e), o = this.findAdjacentTabIndexClosestToEdge(e, n, i, r);
      if (this.indexIsInRange(o)) {
        var c = this.calculateScrollIncrement(e, o, i, r);
        this.adapter.incrementScroll(c);
      }
    }, t.prototype.scrollIntoViewImplRTL = function(e) {
      var i = this.adapter.getScrollPosition(), r = this.adapter.getOffsetWidth(), n = this.adapter.getTabDimensionsAtIndex(e), o = this.adapter.getScrollContentWidth(), c = this.findAdjacentTabIndexClosestToEdgeRTL(e, n, i, r, o);
      if (this.indexIsInRange(c)) {
        var a = this.calculateScrollIncrementRTL(e, c, i, r, o);
        this.adapter.incrementScroll(a);
      }
    }, t;
  }(Ae)
);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Fe = window, us = Fe.ShadowRoot && (Fe.ShadyCSS === void 0 || Fe.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, fs = Symbol(), Wn = /* @__PURE__ */ new WeakMap();
let ma = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== fs) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (us && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = Wn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && Wn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const vd = (s) => new ma(typeof s == "string" ? s : s + "", void 0, fs), gd = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new ma(e, s, fs);
}, $d = (s, t) => {
  us ? s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet) : t.forEach((e) => {
    const i = document.createElement("style"), r = Fe.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  });
}, Kn = us ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return vd(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var er;
const ii = window, Gn = ii.trustedTypes, _d = Gn ? Gn.emptyScript : "", qn = ii.reactiveElementPolyfillSupport, Mr = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? _d : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, va = (s, t) => t !== s && (t == t || s == s), ir = { attribute: !0, type: String, converter: Mr, reflect: !1, hasChanged: va }, Nr = "finalized";
let wt = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(t) {
    var e;
    this.finalize(), ((e = this.h) !== null && e !== void 0 ? e : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((e, i) => {
      const r = this._$Ep(i, e);
      r !== void 0 && (this._$Ev.set(r, i), t.push(r));
    }), t;
  }
  static createProperty(t, e = ir) {
    if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const i = typeof t == "symbol" ? Symbol() : "__" + t, r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && Object.defineProperty(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return { get() {
      return this[e];
    }, set(r) {
      const n = this[t];
      this[e] = r, this.requestUpdate(t, n, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || ir;
  }
  static finalize() {
    if (this.hasOwnProperty(Nr)) return !1;
    this[Nr] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const e = this.properties, i = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(Kn(r));
    } else t !== void 0 && e.push(Kn(t));
    return e;
  }
  static _$Ep(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  _$Eu() {
    var t;
    this._$E_ = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((e) => e(this));
  }
  addController(t) {
    var e, i;
    ((e = this._$ES) !== null && e !== void 0 ? e : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) === null || i === void 0 || i.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return $d(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) === null || i === void 0 ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EO(t, e, i = ir) {
    var r;
    const n = this.constructor._$Ep(t, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) === null || r === void 0 ? void 0 : r.toAttribute) !== void 0 ? i.converter : Mr).toAttribute(e, i.type);
      this._$El = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null;
    }
  }
  _$AK(t, e) {
    var i;
    const r = this.constructor, n = r._$Ev.get(t);
    if (n !== void 0 && this._$El !== n) {
      const o = r.getPropertyOptions(n), c = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? o.converter : Mr;
      this._$El = n, this[n] = c.fromAttribute(e, o.type), this._$El = null;
    }
  }
  requestUpdate(t, e, i) {
    let r = !0;
    t !== void 0 && (((i = i || this.constructor.getPropertyOptions(t)).hasChanged || va)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, i))) : r = !1), !this.isUpdatePending && r && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((r, n) => this[n] = r), this._$Ei = void 0);
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
        var n;
        return (n = r.hostUpdate) === null || n === void 0 ? void 0 : n.call(r);
      }), this.update(i)) : this._$Ek();
    } catch (r) {
      throw e = !1, this._$Ek(), r;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) === null || r === void 0 ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((e, i) => this._$EO(i, this[i], e)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
wt[Nr] = !0, wt.elementProperties = /* @__PURE__ */ new Map(), wt.elementStyles = [], wt.shadowRootOptions = { mode: "open" }, qn == null || qn({ ReactiveElement: wt }), ((er = ii.reactiveElementVersions) !== null && er !== void 0 ? er : ii.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var rr;
const ri = window, Vt = ri.trustedTypes, Xn = Vt ? Vt.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Dr = "$lit$", j = `lit$${(Math.random() + "").slice(9)}$`, ga = "?" + j, yd = `<${ga}>`, gt = document, $e = () => gt.createComment(""), _e = (s) => s === null || typeof s != "object" && typeof s != "function", $a = Array.isArray, bd = (s) => $a(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", sr = `[ 	
\f\r]`, ie = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Zn = /-->/g, Yn = />/g, Q = RegExp(`>|${sr}(?:([^\\s"'>=/]+)(${sr}*=${sr}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Jn = /'/g, Qn = /"/g, _a = /^(?:script|style|textarea|title)$/i, Ad = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), Sd = Ad(1), Wt = Symbol.for("lit-noChange"), x = Symbol.for("lit-nothing"), to = /* @__PURE__ */ new WeakMap(), ot = gt.createTreeWalker(gt, 129, null, !1);
function ya(s, t) {
  if (!Array.isArray(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Xn !== void 0 ? Xn.createHTML(t) : t;
}
const Ed = (s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : "", o = ie;
  for (let c = 0; c < e; c++) {
    const a = s[c];
    let l, h, d = -1, p = 0;
    for (; p < a.length && (o.lastIndex = p, h = o.exec(a), h !== null); ) p = o.lastIndex, o === ie ? h[1] === "!--" ? o = Zn : h[1] !== void 0 ? o = Yn : h[2] !== void 0 ? (_a.test(h[2]) && (r = RegExp("</" + h[2], "g")), o = Q) : h[3] !== void 0 && (o = Q) : o === Q ? h[0] === ">" ? (o = r ?? ie, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? Q : h[3] === '"' ? Qn : Jn) : o === Qn || o === Jn ? o = Q : o === Zn || o === Yn ? o = ie : (o = Q, r = void 0);
    const u = o === Q && s[c + 1].startsWith("/>") ? " " : "";
    n += o === ie ? a + yd : d >= 0 ? (i.push(l), a.slice(0, d) + Dr + a.slice(d) + j + u) : a + j + (d === -2 ? (i.push(void 0), c) : u);
  }
  return [ya(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : "")), i];
};
class ye {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const c = t.length - 1, a = this.parts, [l, h] = Ed(t, e);
    if (this.el = ye.createElement(l, i), ot.currentNode = this.el.content, e === 2) {
      const d = this.el.content, p = d.firstChild;
      p.remove(), d.append(...p.childNodes);
    }
    for (; (r = ot.nextNode()) !== null && a.length < c; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) {
          const d = [];
          for (const p of r.getAttributeNames()) if (p.endsWith(Dr) || p.startsWith(j)) {
            const u = h[o++];
            if (d.push(p), u !== void 0) {
              const v = r.getAttribute(u.toLowerCase() + Dr).split(j), m = /([.?@])?(.*)/.exec(u);
              a.push({ type: 1, index: n, name: m[2], strings: v, ctor: m[1] === "." ? wd : m[1] === "?" ? Td : m[1] === "@" ? Rd : hi });
            } else a.push({ type: 6, index: n });
          }
          for (const p of d) r.removeAttribute(p);
        }
        if (_a.test(r.tagName)) {
          const d = r.textContent.split(j), p = d.length - 1;
          if (p > 0) {
            r.textContent = Vt ? Vt.emptyScript : "";
            for (let u = 0; u < p; u++) r.append(d[u], $e()), ot.nextNode(), a.push({ type: 2, index: ++n });
            r.append(d[p], $e());
          }
        }
      } else if (r.nodeType === 8) if (r.data === ga) a.push({ type: 2, index: n });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(j, d + 1)) !== -1; ) a.push({ type: 7, index: n }), d += j.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = gt.createElement("template");
    return i.innerHTML = t, i;
  }
}
function Kt(s, t, e = s, i) {
  var r, n, o, c;
  if (t === Wt) return t;
  let a = i !== void 0 ? (r = e._$Co) === null || r === void 0 ? void 0 : r[i] : e._$Cl;
  const l = _e(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== l && ((n = a == null ? void 0 : a._$AO) === null || n === void 0 || n.call(a, !1), l === void 0 ? a = void 0 : (a = new l(s), a._$AT(s, e, i)), i !== void 0 ? ((o = (c = e)._$Co) !== null && o !== void 0 ? o : c._$Co = [])[i] = a : e._$Cl = a), a !== void 0 && (t = Kt(s, a._$AS(s, t.values), a, i)), t;
}
class Cd {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var e;
    const { el: { content: i }, parts: r } = this._$AD, n = ((e = t == null ? void 0 : t.creationScope) !== null && e !== void 0 ? e : gt).importNode(i, !0);
    ot.currentNode = n;
    let o = ot.nextNode(), c = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (c === l.index) {
        let h;
        l.type === 2 ? h = new Ce(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new Pd(o, this, t)), this._$AV.push(h), l = r[++a];
      }
      c !== (l == null ? void 0 : l.index) && (o = ot.nextNode(), c++);
    }
    return ot.currentNode = gt, n;
  }
  v(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}
class Ce {
  constructor(t, e, i, r) {
    var n;
    this.type = 2, this._$AH = x, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cp = (n = r == null ? void 0 : r.isConnected) === null || n === void 0 || n;
  }
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && e !== void 0 ? e : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Kt(this, t, e), _e(t) ? t === x || t == null || t === "" ? (this._$AH !== x && this._$AR(), this._$AH = x) : t !== this._$AH && t !== Wt && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : bd(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== x && _e(this._$AH) ? this._$AA.nextSibling.data = t : this.$(gt.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var e;
    const { values: i, _$litType$: r } = t, n = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = ye.createElement(ya(r.h, r.h[0]), this.options)), r);
    if (((e = this._$AH) === null || e === void 0 ? void 0 : e._$AD) === n) this._$AH.v(i);
    else {
      const o = new Cd(n, this), c = o.u(this.options);
      o.v(i), this.$(c), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = to.get(t.strings);
    return e === void 0 && to.set(t.strings, e = new ye(t)), e;
  }
  T(t) {
    $a(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new Ce(this.k($e()), this.k($e()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cp = t, (e = this._$AP) === null || e === void 0 || e.call(this, t));
  }
}
class hi {
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = x, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = x;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) t = Kt(this, t, e, 0), o = !_e(t) || t !== this._$AH && t !== Wt, o && (this._$AH = t);
    else {
      const c = t;
      let a, l;
      for (t = n[0], a = 0; a < n.length - 1; a++) l = Kt(this, c[i + a], e, a), l === Wt && (l = this._$AH[a]), o || (o = !_e(l) || l !== this._$AH[a]), l === x ? t = x : t !== x && (t += (l ?? "") + n[a + 1]), this._$AH[a] = l;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === x ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class wd extends hi {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === x ? void 0 : t;
  }
}
const xd = Vt ? Vt.emptyScript : "";
class Td extends hi {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== x ? this.element.setAttribute(this.name, xd) : this.element.removeAttribute(this.name);
  }
}
class Rd extends hi {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    var i;
    if ((t = (i = Kt(this, t, e, 0)) !== null && i !== void 0 ? i : x) === Wt) return;
    const r = this._$AH, n = t === x && r !== x || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== x && (r === x || n);
    n && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, i;
    typeof this._$AH == "function" ? this._$AH.call((i = (e = this.options) === null || e === void 0 ? void 0 : e.host) !== null && i !== void 0 ? i : this.element, t) : this._$AH.handleEvent(t);
  }
}
class Pd {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Kt(this, t);
  }
}
const eo = ri.litHtmlPolyfillSupport;
eo == null || eo(ye, Ce), ((rr = ri.litHtmlVersions) !== null && rr !== void 0 ? rr : ri.litHtmlVersions = []).push("2.8.0");
const Od = (s, t, e) => {
  var i, r;
  const n = (i = e == null ? void 0 : e.renderBefore) !== null && i !== void 0 ? i : t;
  let o = n._$litPart$;
  if (o === void 0) {
    const c = (r = e == null ? void 0 : e.renderBefore) !== null && r !== void 0 ? r : null;
    n._$litPart$ = o = new Ce(t.insertBefore($e(), c), c, void 0, e ?? {});
  }
  return o._$AI(s), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var nr, or;
class Ve extends wt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (t = (e = this.renderOptions).renderBefore) !== null && t !== void 0 || (e.renderBefore = i.firstChild), i;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Od(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return Wt;
  }
}
Ve.finalized = !0, Ve._$litElement$ = !0, (nr = globalThis.litElementHydrateSupport) === null || nr === void 0 || nr.call(globalThis, { LitElement: Ve });
const io = globalThis.litElementPolyfillSupport;
io == null || io({ LitElement: Ve });
((or = globalThis.litElementVersions) !== null && or !== void 0 ? or : globalThis.litElementVersions = []).push("3.3.3");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class we extends be {
  constructor() {
    super(...arguments), this.mdcFoundationClass = Vn, this.activeIndex = 0, this._previousActiveIndex = -1;
  }
  _handleTabInteraction(t) {
    this.mdcFoundation.handleTabInteraction(t);
  }
  _handleKeydown(t) {
    this.mdcFoundation.handleKeyDown(t);
  }
  // TODO(sorvell): can scroller be optional for perf?
  render() {
    return Sd`
      <div class="mdc-tab-bar" role="tablist"
          @MDCTab:interacted="${this._handleTabInteraction}"
          @keydown="${this._handleKeydown}">
        <mwc-tab-scroller><slot></slot></mwc-tab-scroller>
      </div>
      `;
  }
  // TODO(sorvell): probably want to memoize this and use a `slotChange` event
  _getTabs() {
    return this.tabsSlot.assignedNodes({ flatten: !0 }).filter((t) => t instanceof _);
  }
  _getTab(t) {
    return this._getTabs()[t];
  }
  createAdapter() {
    return {
      scrollTo: (t) => this.scrollerElement.scrollToPosition(t),
      incrementScroll: (t) => this.scrollerElement.incrementScrollPosition(t),
      getScrollPosition: () => this.scrollerElement.getScrollPosition(),
      getScrollContentWidth: () => this.scrollerElement.getScrollContentWidth(),
      getOffsetWidth: () => this.mdcRoot.offsetWidth,
      isRTL: () => window.getComputedStyle(this.mdcRoot).getPropertyValue("direction") === "rtl",
      setActiveTab: (t) => this.mdcFoundation.activateTab(t),
      activateTabAtIndex: (t, e) => {
        const i = this._getTab(t);
        i !== void 0 && i.activate(e), this._previousActiveIndex = t;
      },
      deactivateTabAtIndex: (t) => {
        const e = this._getTab(t);
        e !== void 0 && e.deactivate();
      },
      focusTabAtIndex: (t) => {
        const e = this._getTab(t);
        e !== void 0 && e.focus();
      },
      // TODO(sorvell): tab may not be able to synchronously answer
      // `computeIndicatorClientRect` if an update is pending or it has not yet
      // updated. If this is necessary, LitElement may need a `forceUpdate`
      // method.
      getTabIndicatorClientRectAtIndex: (t) => {
        const e = this._getTab(t);
        return e !== void 0 ? e.computeIndicatorClientRect() : new DOMRect();
      },
      getTabDimensionsAtIndex: (t) => {
        const e = this._getTab(t);
        return e !== void 0 ? e.computeDimensions() : { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };
      },
      getPreviousActiveTabIndex: () => this._previousActiveIndex,
      getFocusedTabIndex: () => {
        const t = this._getTabs(), e = this.getRootNode().activeElement;
        return t.indexOf(e);
      },
      getIndexOfTabById: (t) => {
        const e = this._getTabs();
        for (let i = 0; i < e.length; i++)
          if (e[i].id === t)
            return i;
        return -1;
      },
      getTabListLength: () => this._getTabs().length,
      notifyTabActivated: (t) => {
        this.activeIndex = t, this.dispatchEvent(new CustomEvent(Vn.strings.TAB_ACTIVATED_EVENT, { detail: { index: t }, bubbles: !0, cancelable: !0 }));
      }
    };
  }
  firstUpdated() {
  }
  async getUpdateComplete() {
    const t = await super.getUpdateComplete();
    return await this.scrollerElement.updateComplete, this.mdcFoundation === void 0 && this.createFoundation(), t;
  }
  scrollIndexIntoView(t) {
    this.mdcFoundation.scrollIntoView(t);
  }
}
f([
  Gr(".mdc-tab-bar")
], we.prototype, "mdcRoot", void 0);
f([
  Gr("mwc-tab-scroller")
], we.prototype, "scrollerElement", void 0);
f([
  Gr("slot")
], we.prototype, "tabsSlot", void 0);
f([
  Yo(async function() {
    await this.updateComplete, this.activeIndex !== this._previousActiveIndex && this.mdcFoundation.activateTab(this.activeIndex);
  }),
  Ja({ type: Number })
], we.prototype, "activeIndex", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const kd = gd`.mdc-tab-bar{width:100%}.mdc-tab{height:48px}.mdc-tab--stacked{height:72px}:host{display:block}.mdc-tab-bar{flex:1}mwc-tab{--mdc-tab-height: 48px;--mdc-tab-stacked-height: 72px}`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let zr = class extends we {
};
zr.styles = [kd];
zr = f([
  Xa("mwc-tab-bar")
], zr);
var ao, lr, Ud;
ao = [Wr("ht-location-inspector")];
let Tt = class Tt extends (Ud = lt) {
  constructor() {
    super(...arguments), this._activeTab = "occupancy";
  }
  render() {
    return this.location ? g`
      <div class="inspector-container">
        ${this._renderHeader()} ${this._renderTabs()} ${this._renderContent()}
      </div>
    ` : g`
        <div class="empty-state">
          <div class="empty-state-icon">üëà</div>
          <div>Select a location to view details</div>
        </div>
      `;
  }
  _renderHeader() {
    if (!this.location) return "";
    const t = this.location.modules._meta, e = this._getLocationIcon((t == null ? void 0 : t.type) || "room");
    return g`
      <div class="header">
        <div class="header-icon">${e}</div>
        <div class="header-content">
          <div class="location-name">${this.location.name}</div>
          <div class="location-id">${this.location.id}</div>
        </div>
      </div>
    `;
  }
  _renderTabs() {
    const t = this._activeTab === "occupancy" ? 0 : 1;
    return g`
      <div class="tabs">
        <mwc-tab-bar
          .activeIndex=${t}
          @MDCTabBar:activated=${this._handleTabActivated}
        >
          <mwc-tab label="Occupancy"></mwc-tab>
          <mwc-tab label="Actions"></mwc-tab>
        </mwc-tab-bar>
      </div>
    `;
  }
  _handleTabActivated(t) {
    const e = t.detail.index;
    this._activeTab = e === 0 ? "occupancy" : "actions";
  }
  _renderContent() {
    return g`
      <div class="tab-content">
        ${this._activeTab === "occupancy" ? this._renderOccupancyTab() : this._renderActionsTab()}
      </div>
    `;
  }
  _renderOccupancyTab() {
    if (!this.location) return "";
    const t = this.location.modules.occupancy || {}, e = t.enabled ?? !0, i = t.default_timeout || 300;
    return g`
      <div>
        <div class="section-header">PRESENCE LOGIC</div>
        <div class="config-row">
          <div class="config-label">Enable Occupancy Tracking</div>
          <div class="config-value">
            <div class="toggle ${e ? "on" : ""}" @click=${this._toggleEnabled}>
            </div>
          </div>
        </div>

        ${e ? g`
              <div class="config-row">
                <div class="config-label">Default Timeout</div>
                <div class="config-value">
                  <input
                    type="number"
                    class="input"
                    .value=${Math.floor(i / 60)}
                    @change=${this._handleTimeoutChange}
                  />
                  <span class="text-muted">minutes</span>
                </div>
              </div>

              <div class="section-header">OCCUPANCY SOURCES</div>
              <div class="sources-list">
                ${this._renderOccupancySources(t)}
              </div>
            ` : ""}
      </div>
    `;
  }
  _renderOccupancySources(t) {
    const e = t.occupancy_sources || [];
    return e.length ? e.map(
      (i) => g`
        <div class="source-item">
          <div class="source-icon">‚äô</div>
          <div class="source-info">
            <div class="source-name">${i.entity_id}</div>
            <div class="source-details">
              ${i.mode === "any_change" ? "Any Change" : "Specific States"}
              ${i.on_timeout ? ` ‚Ä¢ ${Math.floor(i.on_timeout / 60)}min` : ""}
            </div>
          </div>
          <button class="icon-button">‚öôÔ∏è</button>
        </div>
      `
    ) : g`
        <div class="empty-state">
          <div class="text-muted">
            No occupancy sources configured. Add sensors to track occupancy.
          </div>
          <button class="button button-primary" style="margin-top: 16px;">
            + Add Source
          </button>
        </div>
      `;
  }
  _renderActionsTab() {
    if (!this.location) return "";
    const e = (this.location.modules.automation || {}).rules || [];
    return g`
      <div>
        <div class="section-header">AUTOMATION RULES</div>

        <div class="actions">
          <button class="button button-primary" @click=${this._handleAddRule}>
            + Add Rule
          </button>
        </div>

        <div class="rules-list" style="margin-top: var(--spacing-md);">
          ${e.length === 0 ? g`
                  <div class="empty-state">
                    <div class="text-muted">No automation rules configured.</div>
                  </div>
                ` : e.map(
      (i) => g`
                    <div class="source-item">
                      <div class="source-icon">‚ö°</div>
                      <div class="source-info">
                        <div class="source-name">${i.name}</div>
                        <div class="source-details">
                          When ${i.trigger_type} ‚Üí ${i.action_service} (${i.action_entity_id})
                        </div>
                      </div>
                      <button class="icon-button" @click=${() => this._handleDeleteRule(i.id)}>üóëÔ∏è</button>
                    </div>
                  `
    )}
        </div>
      </div>
    `;
  }
  _handleAddRule() {
    alert("Rule editor dialog coming in next iteration");
  }
  async _handleDeleteRule(t) {
    if (!confirm("Are you sure you want to delete this rule?") || !this.location) return;
    const e = this.location.modules.automation || {}, r = (e.rules || []).filter((n) => n.id !== t);
    await this._updateModuleConfig("automation", { ...e, rules: r });
  }
  async _updateModuleConfig(t, e) {
    if (this.location)
      try {
        await this.hass.callWS({
          type: "home_topology/locations/set_module_config",
          location_id: this.location.id,
          module_id: t,
          config: e
        }), this.location.modules[t] = e, this.requestUpdate();
      } catch (i) {
        console.error("Failed to update config:", i), alert("Failed to update configuration");
      }
  }
  _getLocationIcon(t) {
    return {
      floor: "‚â°",
      room: "‚óé",
      zone: "‚óá",
      suite: "‚ùñ",
      outdoor: "‚åÇ",
      building: "‚ñ£"
    }[t] || "‚óé";
  }
  _toggleEnabled() {
    if (!this.location) return;
    const t = this.location.modules.occupancy || {}, e = !(t.enabled ?? !0);
    this._updateConfig({ ...t, enabled: e });
  }
  _handleTimeoutChange(t) {
    const e = t.target, r = parseInt(e.value, 10) * 60;
    if (!this.location) return;
    const n = this.location.modules.occupancy || {};
    this._updateConfig({ ...n, default_timeout: r });
  }
  async _updateConfig(t) {
    await this._updateModuleConfig("occupancy", t);
  }
};
lr = xe(Ud), Tt = Re(lr, 0, "HtLocationInspector", ao, Tt), Tt.styles = [
  Kr,
  si`
      :host {
        display: block;
        height: 100%;
        overflow-y: auto;
      }

      .inspector-container {
        padding: var(--spacing-md);
      }

      .header {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
        padding-bottom: var(--spacing-md);
        border-bottom: 1px solid var(--divider-color);
      }

      .header-icon {
        font-size: 32px;
      }

      .header-content {
        flex: 1;
      }

      .location-name {
        font-size: 20px;
        font-weight: 500;
        margin-bottom: var(--spacing-xs);
      }

      .location-id {
        font-size: 12px;
        color: var(--text-secondary-color);
      }

      .tabs {
        margin-bottom: var(--spacing-md);
        border-bottom: 1px solid var(--divider-color);
        background: var(--card-background-color);
      }

      .tab-content {
        padding: var(--spacing-md) 0;
      }

      .config-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--spacing-md) 0;
        border-bottom: 1px solid var(--divider-color);
      }

      .config-row:last-child {
        border-bottom: none;
      }

      .config-label {
        font-size: 14px;
        font-weight: 500;
      }

      .config-value {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }

      .toggle {
        width: 44px;
        height: 24px;
        border-radius: 12px;
        background: var(--disabled-color);
        position: relative;
        cursor: pointer;
        transition: background var(--transition-speed);
      }

      .toggle.on {
        background: var(--primary-color);
      }

      .toggle::after {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: white;
        top: 2px;
        left: 2px;
        transition: transform var(--transition-speed);
      }

      .toggle.on::after {
        transform: translateX(20px);
      }

      .input {
        padding: var(--spacing-sm);
        border: 1px solid var(--divider-color);
        border-radius: var(--border-radius);
        font-size: 14px;
        width: 80px;
      }

      .sources-list {
        margin-top: var(--spacing-md);
      }

      .source-item {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        padding: var(--spacing-md);
        background: var(--card-background-color);
        border: 1px solid var(--divider-color);
        border-radius: var(--border-radius);
        margin-bottom: var(--spacing-sm);
      }

      .source-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .source-info {
        flex: 1;
      }

      .source-name {
        font-size: 14px;
        font-weight: 500;
      }

      .source-details {
        font-size: 12px;
        color: var(--text-secondary-color);
        margin-top: var(--spacing-xs);
      }
    `
], Te(lr, 1, Tt);
let ro = Tt;
var lo, cr, Ld;
lo = [Wr("home-topology-panel")];
let Rt = class Rt extends (Ld = lt) {
  constructor() {
    super(...arguments), this.narrow = !1, this._locations = [], this._loading = !0;
  }
  connectedCallback() {
    super.connectedCallback(), this._loadLocations();
  }
  render() {
    if (this._loading)
      return g`
        <div class="loading-container">
          <div class="spinner"></div>
          <div class="text-muted">Loading locations...</div>
        </div>
      `;
    if (this._error)
      return g`
        <div class="error-container">
          <h3>Error Loading Home Topology</h3>
          <p>${this._error}</p>
          <button class="button button-primary" @click=${this._loadLocations}>
            Retry
          </button>
        </div>
      `;
    const t = this._locations.find(
      (e) => e.id === this._selectedId
    );
    return g`
      <div class="panel-container">
        <div class="panel-left">
          <div class="header">
            <div class="header-title">Home Topology</div>
            <div class="header-subtitle">
              Model your space and configure behaviors
            </div>
            <button class="button button-secondary" style="margin-top: 8px; width: 100%" @click=${this._seedDemoData}>
              ‚ö° Seed Demo Data
            </button>
          </div>
          <ht-location-tree
            .hass=${this.hass}
            .locations=${this._locations}
            .selectedId=${this._selectedId}
            @location-selected=${this._handleLocationSelected}
            @location-create=${this._handleLocationCreate}
          ></ht-location-tree>
        </div>

        <div class="panel-right">
          <ht-location-inspector
            .hass=${this.hass}
            .location=${t}
          ></ht-location-inspector>
        </div>
      </div>
    `;
  }
  async _loadLocations() {
    this._loading = !0, this._error = void 0;
    try {
      const t = await this.hass.callWS({
        type: "home_topology/locations/list"
      });
      this._locations = t.locations, !this._selectedId && this._locations.length > 0 && (this._selectedId = this._locations[0].id);
    } catch (t) {
      console.error("Failed to load locations:", t), this._error = t.message || "Failed to load locations";
    } finally {
      this._loading = !1;
    }
  }
  _handleLocationSelected(t) {
    this._selectedId = t.detail.locationId;
  }
  _handleLocationCreate() {
    alert("Create location dialog coming soon");
  }
  async _seedDemoData() {
    if (!confirm("This will create a demo topology. Continue?")) return;
    const t = [
      { id: "ground_floor", name: "Ground Floor", type: "floor", parent_id: "house" },
      { id: "living_room", name: "Living Room", type: "room", parent_id: "ground_floor" },
      { id: "reading_corner", name: "Reading Corner", type: "zone", parent_id: "living_room" },
      { id: "kitchen", name: "Kitchen", type: "room", parent_id: "ground_floor" },
      { id: "dining_room", name: "Dining Room", type: "room", parent_id: "ground_floor" },
      { id: "hallway", name: "Hallway", type: "room", parent_id: "ground_floor" },
      { id: "office", name: "Office", type: "room", parent_id: "ground_floor" },
      { id: "garage", name: "Garage", type: "room", parent_id: "ground_floor" },
      { id: "first_floor", name: "First Floor", type: "floor", parent_id: "house" },
      { id: "master_suite", name: "Master Suite", type: "suite", parent_id: "first_floor" },
      { id: "master_bedroom", name: "Master Bedroom", type: "room", parent_id: "master_suite" },
      { id: "master_bath", name: "Master Bath", type: "room", parent_id: "master_suite" },
      { id: "kids_room", name: "Kids Room", type: "room", parent_id: "first_floor" },
      { id: "guest_room", name: "Guest Room", type: "room", parent_id: "first_floor" },
      { id: "outdoor", name: "Outdoor", type: "outdoor", parent_id: "house" },
      { id: "patio", name: "Patio", type: "zone", parent_id: "outdoor" },
      { id: "garden", name: "Garden", type: "zone", parent_id: "outdoor" }
    ];
    try {
      this._loading = !0;
      for (const e of t) {
        console.log(`Creating ${e.name}...`);
        try {
          await this.hass.callWS({
            type: "home_topology/locations/create",
            name: e.name,
            parent_id: e.parent_id,
            meta: { type: e.type }
          });
        } catch (i) {
          console.warn(`Failed to create ${e.name} (might exist):`, i);
        }
      }
      await this._loadLocations(), alert("Demo data seeded successfully!");
    } catch (e) {
      console.error("Seeding failed:", e), alert(`Seeding failed: ${e.message}`);
    } finally {
      this._loading = !1;
    }
  }
};
cr = xe(Ld), Rt = Re(cr, 0, "HomeTopologyPanel", lo, Rt), Rt.styles = [
  Kr,
  si`
      :host {
        display: block;
        height: 100%;
        background: var(--primary-background-color, #fafafa);
      }

      .panel-container {
        display: flex;
        height: 100%;
        gap: 1px;
        background: var(--divider-color);
      }

      .panel-left {
        flex: 0 0 400px;
        background: var(--card-background-color);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .panel-right {
        flex: 1;
        background: var(--card-background-color);
        overflow: hidden;
      }

      @media (max-width: 1024px) {
        .panel-left {
          flex: 0 0 300px;
        }
      }

      @media (max-width: 768px) {
        .panel-container {
          flex-direction: column;
        }

        .panel-left,
        .panel-right {
          flex: 1;
        }
      }

      .header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--divider-color);
      }

      .header-title {
        font-size: 24px;
        font-weight: 500;
        margin-bottom: var(--spacing-xs);
      }

      .header-subtitle {
        font-size: 14px;
        color: var(--text-secondary-color);
      }

      .loading-container {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        flex-direction: column;
        gap: var(--spacing-md);
      }

      .spinner {
        border: 3px solid var(--divider-color);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .error-container {
        padding: var(--spacing-lg);
        color: var(--error-color);
      }
    `
], Te(cr, 1, Rt);
let so = Rt;
export {
  so as HomeTopologyPanel
};
