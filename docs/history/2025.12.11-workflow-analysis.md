# Home Topology UI Mock - Epic & Workflow

**Date**: 2025-12-11
**Status**: Active
**Owner**: Development Team
**Target**: Complete UI mock with validated interactions

---

## Epic Overview

### Goal

Create a complete, validated UI mock for the Home Topology Location Manager that demonstrates all core interactions, validates design decisions, and provides a specification for the Lit-based implementation in Home Assistant.

### Success Criteria

1. **All interactions work in the mock harness**:

   - Tree navigation (expand/collapse, select)
   - Drag-and-drop reordering with hierarchy validation
   - Location creation with HA area linkage options
   - Rename with bidirectional HA sync handling
   - Delete with HA area impact and unlink options
   - Entity assignment (filtered by HA area)

2. **HA linkage behaviors demonstrated**:

   - Badge indicators (HA vs Local origin)
   - HA area creation/linking checkbox in dialogs
   - Rename conflict resolution UI (HA registry updates)
   - Delete confirmation with HA impact warnings
   - Unlink option (keep in HA, move to Inbox)

3. **Hierarchy constraints enforced**:

   - Visual feedback for invalid drops (floorâ†’floor, room nesting)
   - Tooltip messages for blocked operations
   - Multiple roots supported (House, Garage, Outdoor, Inbox)

4. **Documentation complete**:
   - All interactions documented in ui-design.md
   - UX copy for dialogs, tooltips, confirmations
   - Edge cases and error states specified

### Non-Goals

- Full backend implementation (mock data only)
- Performance optimization (not representative at mock scale)
- Production-ready Lit components (mock uses simpler approach)
- Complete module configuration (focus on location management)

---

## Scope

### In Scope

**Core Interactions**:

- Tree panel: select, expand/collapse, drag/drop, inline rename
- Details panel: location info, module tabs, entity list
- Dialogs: create location, delete confirmation, entity configuration
- State indicators: occupancy status, pending changes, HA linkage badges

**HA Integration Behaviors**:

- Location â†” HA area one-to-one mapping
- Origin tracking (HA-imported vs integration-created)
- Bidirectional rename sync with conflict resolution
- Delete propagation with unlink option
- Floor linkage (when HA floors supported)

**Hierarchy Management**:

- Type-based hierarchy rules (Floor â†’ Room, Room terminal, no floor nesting)
- Drag-and-drop validation and feedback
- Multiple root support (House, Garage, Outdoor)
- Inbox for unassigned entities and unlinked locations

### Out of Scope

- Actions module configuration (preliminary design only)
- Advanced module settings (defer to implementation)
- Bulk operations (multi-select, copy/paste configs)
- Floor plan view, graph view (future visualizations)
- Full WebSocket real-time updates (mock uses manual refresh)
- Undo/Redo implementation (UI placeholder only)

---

## Dependencies

**External**:

- Home Assistant area registry API patterns
- Home Assistant floor registry (optional, may not be available)
- SortableJS library for drag-and-drop
- Home Assistant Lit component library (`ha-*`)

**Internal**:

- Core library location hierarchy (type-agnostic)
- Integration layer HA area sync service
- `_meta` module convention for type/category/icon storage
- Occupancy module configuration schema

**Documentation**:

- `docs/ui-design.md` (UI design specification)
- `docs/mock-component-strategy.md` (how to mock HA components in harness)
- `docs/frontend-dev-workflow.md` (development workflow)
- `docs/frontend-patterns.md` (Lit patterns, performance, drag-drop)

---

## Risks & Mitigations

| Risk                              | Impact | Likelihood | Mitigation                                                                |
| --------------------------------- | ------ | ---------- | ------------------------------------------------------------------------- |
| HA floors not available           | Medium | High       | Make floor linkage optional; support integration-only floors              |
| Drag-and-drop complexity          | High   | Medium     | Use proven SortableJS; test iteratively with browser tools                |
| HA area sync conflicts            | Medium | Medium     | Surface conflicts with "updated in HA" chip; prefer HA as source of truth |
| Hierarchy rules too restrictive   | Medium | Low        | Allow API bypass for power users; document constraints clearly            |
| Mock diverges from implementation | High   | Medium     | Keep mock simple; focus on interactions not implementation details        |

---

## Key Constraints

### Architectural Layers

**Important**: home-topology has three distinct layers with different responsibilities:

1. **Kernel (core library)**: Type-agnostic. Only knows `Location` objects in a tree. No concept of "floor", "room", "building".
2. **Integration layer**: Defines location types (floor/room/building/outdoor) via `modules["_meta"]`. Enforces hierarchy rules in UI.
3. **Home Assistant**: Has Areas (flat), Floors (optional grouping), and Zones (GPS geofences, not indoor topology).

### Technical Constraints

1. **Hierarchy Rules (Integration UI-Enforced Only)**:

   - **Kernel**: Type-agnostic; any Location can parent any other (only prevents cycles)
   - **Integration UI**: Enforces sensible hierarchy to prevent user confusion:
     - Floors cannot nest (no Floor â†’ Floor)
     - Rooms are terminal (no Room â†’ Room, no Room â†’ Floor)
     - Buildings and Outdoor are root-level only
   - These are **UI validations**, not kernel constraints (power users can bypass via API)

2. **HA Integration Mapping**:

   - One Location = one HA Area (one-to-one mapping)
   - HA Areas are flat (no hierarchy); integration manages the tree structure
   - HA Floors (optional): Integration links Locations to HA floor_id when available
   - HA Zones: GPS-based geofences (e.g., "home", "work"); **not** used for indoor topology
   - HA has no concept of hierarchy/order; that's integration-only

3. **Mock Harness Limitations**:
   - Mock data only (no real backend)
   - Manual refresh for state updates (no live WebSocket)
   - Simplified error handling
   - Not performance-representative

### User Experience Constraints

1. **Bidirectional Sync Challenges**:

   - Rename conflicts possible (user edits locally, HA updates externally)
   - Delete impact must be crystal clear (HA area will be deleted)
   - Unlink option required (keep in HA, remove from topology)

2. **Discoverability**:

   - HA/Local badges must be visible and understandable
   - Invalid drag operations need immediate visual feedback
   - Error messages must guide toward correct action

3. **Consistency with HA Patterns**:
   - Match HA's area management UX where possible
   - Use HA's dialog/confirmation patterns
   - Follow HA's error message tone

---

## Open Questions

1. **HA Floors Support**: Do we assume HA floors exist, or is it optional?

   - **Resolution needed by**: Mock dialog design
   - **Impact**: Floor creation checkbox, floor_id linkage
   - **Proposed approach**: Make floors optional; support integration-only floors as fallback

2. **Uninstall Cleanup**: When integration is removed, delete integration-created HA areas?

   - **Resolution needed by**: Epic completion
   - **Impact**: User trust, data persistence expectations
   - **Options**:
     - a) Delete all integration-created areas (clean uninstall)
     - b) Leave all areas (user manually cleans up)
     - c) Prompt user on uninstall (choose behavior)

3. **Conflict Resolution**: When HA area renamed externally, which takes precedence?

   - **Working assumption**: HA wins; show "updated in HA" toast with "keep local name" option
   - **Validation needed**: User testing
   - **Edge case**: What if both renamed to different values?

4. **Inbox Behavior**: Should unassigned entities auto-appear in Inbox, or manual assignment only?

   - **Working assumption**: Auto-appear with "Assign to Location" dropdown
   - **Validation needed**: UX review
   - **Alternative**: Hide unassigned until user clicks "Show Unassigned"

5. **Multiple Roots Default**: Should new installs default to single "House" root or multiple roots?
   - **Working assumption**: Start with "House" + "Inbox"; let user create Garage/Outdoor as needed
   - **Validation needed**: First-run experience review

---

## Workflow Phases

### Phase 1: Discovery & Validation (Current)

**Objective**: Validate design decisions through working mock interactions

**Owner**: AI Developer (with user review)

**Activities**:

1. Update mock components to reflect HA linkage rules
2. Implement drag-and-drop with hierarchy validation
3. Add HA/Local badges to tree nodes
4. Create/update dialogs with HA area checkbox
5. Add rename conflict resolution UI
6. Implement delete confirmation with HA impact warnings

**Checkpoints**:

- [ ] Tree navigation works (select, expand, drag)
- [ ] Hierarchy constraints enforced (visual feedback on invalid drops)
- [ ] Create location dialog shows HA area option
- [ ] Delete confirmation shows HA area impact
- [ ] Rename conflict resolution UI mocked
- [ ] Multiple roots visible (House, Garage, Outdoor, Inbox)

**Artifacts**:

- Working mock harness with all interactions
- Screenshots of key states (normal, error, conflict)
- Updated ui-design.md with UX copy

**Acceptance Criteria**:

- All interactions testable in browser
- No console errors during normal operations
- Visual feedback clear and consistent
- User can complete all core workflows without confusion

**Estimated Duration**: 2-3 sessions

---

### Phase 2: Documentation & Specification

**Objective**: Complete specification for implementation team

**Owner**: AI Developer

**Activities**:

1. Document all UX copy (tooltips, confirmations, error messages)
2. Capture edge cases and error states
3. Define WebSocket API contracts for HA area sync
4. Document component interaction patterns
5. Create implementation checklist

**Checkpoints**:

- [ ] All dialog copy documented
- [ ] Tooltip text for invalid operations specified
- [ ] HA area sync event flow documented
- [ ] Component state machine documented
- [ ] Acceptance tests defined

**Artifacts**:

- Complete ui-design.md with UX copy section
- WebSocket API contract (added to integration-guide.md)
- Implementation checklist
- Acceptance test scenarios

**Acceptance Criteria**:

- Developer can implement without making UX decisions
- All user-facing text specified
- All error states have defined messages
- API contracts complete

**Estimated Duration**: 1-2 sessions

---

### Phase 3: Review & Handoff

**Objective**: Validate with stakeholders and prepare for implementation

**Owner**: User + AI Developer

**Activities**:

1. Stakeholder demo of mock harness
2. Gather feedback on interactions
3. Identify any missing workflows
4. Prioritize Phase 1 vs Phase 2 features for implementation
5. Create implementation tickets

**Checkpoints**:

- [ ] User accepts mock interactions
- [ ] Open questions resolved
- [ ] Implementation priorities set
- [ ] Tickets created with clear acceptance criteria

**Artifacts**:

- Demo recording or walkthrough document
- Feedback log with resolutions
- Prioritized feature list
- Implementation tickets

**Acceptance Criteria**:

- User approves mock for implementation
- All blockers resolved
- Implementation team has clear backlog
- Success metrics defined

**Estimated Duration**: 1 session + async review

---

### Phase 4: Implementation Support (Future)

**Objective**: Support Lit-based implementation in Home Assistant

**Owner**: Implementation Team (with AI support)

**Activities**:

- Answer questions on mock behavior
- Clarify edge cases as discovered
- Review implementation for spec compliance
- Test implementation against mock

**Out of scope for this epic**: Actual implementation work (separate epic)

---

## Timeline & Milestones

### Phase 1: Discovery & Validation

**Timeline**: 2-3 sessions (current phase)

| Milestone                   | Target    | Status         | Acceptance                                    |
| --------------------------- | --------- | -------------- | --------------------------------------------- |
| M1: HA linkage UI complete  | Session 1 | â³ In Progress | Badges, dialogs, conflict UI visible          |
| M2: Drag-and-drop validated | Session 2 | ðŸ”œ Next        | All drag scenarios work, constraints enforced |
| M3: All interactions tested | Session 3 | ðŸ”œ Pending     | Zero console errors, all workflows complete   |

### Phase 2: Documentation & Specification

**Timeline**: 1-2 sessions

| Milestone                    | Target    | Status     | Acceptance                                   |
| ---------------------------- | --------- | ---------- | -------------------------------------------- |
| M4: UX copy finalized        | Session 4 | ðŸ”œ Pending | All dialog text, tooltips, errors documented |
| M5: API contracts defined    | Session 5 | ðŸ”œ Pending | WebSocket commands specified                 |
| M6: Implementation checklist | Session 5 | ðŸ”œ Pending | Developer-ready spec complete                |

### Phase 3: Review & Handoff

**Timeline**: 1 session + async review

| Milestone                   | Target    | Status     | Acceptance            |
| --------------------------- | --------- | ---------- | --------------------- |
| M7: Stakeholder demo        | Session 6 | ðŸ”œ Pending | User accepts mock     |
| M8: Open questions resolved | Session 6 | ðŸ”œ Pending | No UX blockers remain |
| M9: Implementation tickets  | Session 6 | ðŸ”œ Pending | Backlog ready         |

**Total Estimated Duration**: 5-7 sessions over 1-2 weeks

---

## Review Cadence

### During Development (Phase 1-2)

**Daily Check-ins**:

- AI tests latest mock changes in browser
- AI documents any new issues or questions
- AI updates workflow-analysis.md with progress
- User reviews async, provides feedback

**Ad-hoc Reviews**:

- When major interaction added (drag-and-drop, dialogs)
- When design decision needed (HA behavior, conflict resolution)
- When user requests demo

### Phase Gates

**Phase 1 â†’ Phase 2**:

- **Trigger**: All M1-M3 milestones complete
- **Review**: User confirms all interactions work as expected
- **Approval**: User signs off on mock functionality

**Phase 2 â†’ Phase 3**:

- **Trigger**: M4-M6 milestones complete
- **Review**: Documentation complete, no open UX questions
- **Approval**: User confirms spec is implementation-ready

**Phase 3 â†’ Phase 4**:

- **Trigger**: M7-M9 milestones complete
- **Review**: User approves for implementation handoff
- **Handoff**: Implementation team receives tickets + spec

### Stakeholder Roles

| Role                           | Responsibilities                             | Review Frequency                  |
| ------------------------------ | -------------------------------------------- | --------------------------------- |
| **User (Mike)**                | Final approval, UX decisions, priority calls | Daily (async), Phase gates (sync) |
| **AI Developer**               | Mock implementation, documentation, testing  | Continuous                        |
| **Future Implementation Team** | Lit-based HA integration (separate epic)     | Handoff only                      |

---

## Appendix: Workflow Lessons Learned

> **Note**: This section preserves the 2025-12-10 workflow analysis for reference.

### Test-Driven Development for UI Mocks

**The Problem**: Writing code without testing led to repeated breakage cycles.

**The Solution**:

1. Always use browser tools to test interactions immediately
2. Reproduce issues before fixing
3. Test each change before moving to the next
4. Don't assume code works just because it compiles

**Tools Available**:

- `mcp_cursor-ide-browser_*` for automation
- Console inspection for errors
- Network monitoring for API calls
- Mock harness for isolated testing

**Correct Workflow**:

1. AI tests UI in browser
2. AI identifies problems
3. AI fixes and tests iteratively
4. AI verifies it works
5. User reviews final result

**Anti-Pattern to Avoid**:

1. ~~User tests UI~~
2. ~~User reports problem~~
3. ~~AI writes code~~
4. ~~User tests again~~
5. ~~Repeat until frustrated~~
